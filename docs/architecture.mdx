---
title: Architecture
description: 'Understanding the Brane SDK structure.'
---

## Overview

Brane provides a layered architecture separating client APIs from transport providers.

```mermaid
flowchart TB
    subgraph APP["USER APPLICATION"]
    end

    subgraph BRANE["Brane (sealed interface)"]
        subgraph INTERFACES[" "]
            READER["Brane.Reader<br/>(read-only ops)"]
            SIGNER["Brane.Signer<br/>(read + write ops)"]
        end
        subgraph IMPLS[" "]
            DEFAULT_READER["DefaultReader"]
            DEFAULT_SIGNER["DefaultSigner"]
        end
        READER -->|implements| DEFAULT_READER
        SIGNER -->|implements| DEFAULT_SIGNER
        DEFAULT_SIGNER -->|has-a| DEFAULT_READER
    end

    subgraph PROVIDER["BraneProvider (interface)"]
        HTTP["HttpBraneProvider<br/>• HttpClient<br/>• Stateless"]
        WS["WebSocketProvider<br/>• Netty<br/>• Disruptor<br/>• Subscriptions"]
    end

    subgraph NODE["ETHEREUM NODE (JSON-RPC)"]
    end

    APP --> BRANE
    DEFAULT_READER --> PROVIDER
    DEFAULT_SIGNER --> PROVIDER
    PROVIDER --> NODE
```

## Client Layer

The `Brane` sealed interface is the main entry point:

- **`Brane.Reader`** - Read-only operations: balance queries, block fetching, `eth_call`, event logs
- **`Brane.Signer`** - All Reader operations plus transaction signing and sending

`DefaultSigner` delegates read operations to an internal `DefaultReader` instance.

## Provider Layer

`BraneProvider` abstracts the transport mechanism:

| Provider | Use Case |
|----------|----------|
| `HttpBraneProvider` | Standard request/response, stateless, serverless-friendly |
| `WebSocketProvider` | Real-time subscriptions, persistent connection |

## Module Dependencies

```text
brane-primitives (no dependencies)
         │
         ▼
     brane-core (BouncyCastle, Jackson)
         │
         ▼
      brane-rpc (Netty, Disruptor)
         │
         ▼
    brane-contract
```
