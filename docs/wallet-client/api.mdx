---
title: Sending Transactions
description: 'Interface for signing and sending transactions.'
---


The `WalletClient` is used for writing to the blockchain. It manages accounts, signs transactions, and handles gas estimation.

## Usage

```java
import io.brane.rpc.DefaultWalletClient;
import io.brane.rpc.HttpBraneProvider;
import io.brane.rpc.PublicClient;
import io.brane.core.chain.ChainProfiles;
import io.brane.core.crypto.PrivateKeySigner;

// 1. Create Provider and PublicClient
var provider = HttpBraneProvider.builder("https://rpc.sepolia.org").build();
var publicClient = PublicClient.from(provider);

// 2. Create Signer
var signer = new PrivateKeySigner(System.getenv("SEPOLIA_PRIVATE_KEY"));

// 3. Create Wallet
WalletClient wallet = DefaultWalletClient.create(
    provider,
    publicClient,
    signer,
    ChainProfiles.ETH_SEPOLIA
);
```

## Methods

### sendTransactionAndWait

Sends a transaction and blocks until it is mined. This is the recommended method for scripts and backend services.

```java
TransactionReceipt receipt = wallet.sendTransactionAndWait(
    new TransactionRequest(
        wallet.getAddress(),           // from
        new Address("0x..."),          // to
        Wei.fromEther(new java.math.BigDecimal("0.01")), // value
        null,                          // gasLimit (auto-filled)
        null,                          // gasPrice (not used for EIP-1559)
        null,                          // maxPriorityFeePerGas (auto-filled)
        null,                          // maxFeePerGas (auto-filled)
        null,                          // nonce (auto-fetched)
        null,                          // data
        true,                          // isEip1559
        null                           // accessList
    ),
    60_000, // timeout (ms)
    1_000   // poll interval (ms)
);

System.out.println("Mined in block: " + receipt.blockNumber());
```

### sendTransaction

Sends a transaction immediately and returns the transaction hash. Does not wait for mining.

```java
import io.brane.core.builder.TxBuilder;

TransactionRequest request = TxBuilder.eip1559()
    .to(new Address("0x..."))
    .value(Wei.fromEther(new java.math.BigDecimal("0.1")))
    .build();

// Returns the transaction hash (e.g., "0x...")
String txHash = wallet.sendTransaction(request);
```

### signTransaction

Signs a transaction offline without sending it.

```java
TransactionRequest request = TxBuilder.eip1559()
    .to(new Address("0x..."))
    .value(Wei.fromEther(new java.math.BigDecimal("0.1")))
    .build();

// Returns the signed RLP-encoded transaction hex
String signedTx = wallet.signTransaction(request);
```

### getAddress

Returns the address of the account managed by this wallet.

```java
Address myAddress = wallet.getAddress();
```

## Gas Management

The `WalletClient` automatically handles gas estimation and fee calculation.

*   **Gas Limit**: Estimated via `eth_estimateGas` if not provided.
*   **Fees (EIP-1559)**: `maxFeePerGas` and `maxPriorityFeePerGas` are fetched from the network.
*   **Buffering**: A `SmartGasStrategy` can be configured to add safety buffers to estimates.

## Using Access Lists for Gas Optimization

Generate an EIP-2930 access list and include it in your transaction for 10-20% gas savings on complex contract interactions:

```java
import io.brane.core.model.AccessListWithGas;
import io.brane.core.builder.TxBuilder;
import io.brane.core.types.Address;
import io.brane.core.types.HexData;

Address contractAddress = new Address("0x...");
HexData encodedCall = new HexData("0x..."); // ABI-encoded function call

// 1. Build initial request (without access list)
TransactionRequest initial = TxBuilder.eip1559()
    .from(wallet.getAddress())
    .to(contractAddress)
    .data(encodedCall)
    .build();

// 2. Generate access list via eth_createAccessList
AccessListWithGas result = publicClient.createAccessList(initial);
System.out.println("Estimated gas: " + result.gasUsed());

// 3. Rebuild transaction with access list included
TransactionRequest optimized = TxBuilder.eip1559()
    .from(wallet.getAddress())
    .to(contractAddress)
    .data(encodedCall)
    .accessList(result.accessList())
    .build();

// 4. Send optimized transaction
TransactionReceipt receipt = wallet.sendTransactionAndWait(optimized, 60_000, 1_000);
```
