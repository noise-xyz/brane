---
title: Signers
description: 'Understand how Brane handles transaction and message signing.'
---

## The Signer Interface

In Brane, all signing operations are abstracted through the `Signer` interface. This provides a unified way to sign both transactions and raw messages, whether the key is held locally (e.g., a private key) or remotely (e.g., KMS, HSM, or MPC).

```java
public interface Signer {
    /**
     * Signs a transaction.
     */
    Signature signTransaction(UnsignedTransaction tx, long chainId);

    /**
     * Signs a raw message (EIP-191).
     */
    Signature signMessage(byte[] message);

    /**
     * Returns the address associated with this signer.
     */
    Address address();
}
```

## PrivateKeySigner

The most common implementation is `PrivateKeySigner`, which uses a local private key.

```java
import io.brane.core.crypto.PrivateKeySigner;

// Initialize with a hex private key
var signer = new PrivateKeySigner("0x...");

// Get the address
System.out.println("Address: " + signer.address());
```

## PrivateKey

The underlying `PrivateKey` class handles secp256k1 key operations directly.

### Creating Keys

```java
import io.brane.core.crypto.PrivateKey;

// From hex string (most common)
PrivateKey key = PrivateKey.fromHex("0x...");

// From raw bytes
byte[] keyBytes = loadKeyFromSecureStorage();
PrivateKey key = PrivateKey.fromBytes(keyBytes);
// Note: keyBytes is zeroed after this call for security
```

### Byte Array Ownership

`PrivateKey.fromBytes()` takes ownership of the input byte array and zeros it after extracting the key material. This minimizes exposure of sensitive data in memory.

```java
byte[] keyBytes = loadKeyFromSecureStorage();
PrivateKey key = PrivateKey.fromBytes(keyBytes);
// keyBytes is now all zeros!

// If you need to retain the original bytes, clone first:
byte[] keyBytes = loadKeyFromSecureStorage();
PrivateKey key = PrivateKey.fromBytes(keyBytes.clone());
// keyBytes still contains original data
```

### Key Destruction

`PrivateKey` implements `Destroyable` for explicit cleanup of sensitive material:

```java
PrivateKey key = PrivateKey.fromHex("0x...");
try {
    Address address = key.toAddress();
    Signature sig = key.sign(messageHash);
} finally {
    key.destroy();  // Clear internal references
}

// After destroy(), any operation throws IllegalStateException
key.sign(hash);  // throws IllegalStateException
```

All `PrivateKey` operations are thread-safe. Concurrent signing and destruction are handled correctly.

### Signing Transactions

When using `WalletClient`, the signer is handled automatically. However, you can also sign directly:

```java
import io.brane.core.tx.LegacyTransaction;
import io.brane.core.types.Wei;

// Create an unsigned transaction
var tx = new LegacyTransaction(
    0L,                           // nonce
    Wei.gwei(20),                 // gasPrice
    21000L,                       // gasLimit
    recipientAddress,             // to
    Wei.fromEther(new java.math.BigDecimal("0.01")), // value
    new byte[0]                   // data
);

Signature sig = signer.signTransaction(tx, 1L); // Chain ID 1 (Mainnet)
```

### Signing Messages

You can sign arbitrary messages, which is useful for authentication (e.g., "Sign in with Ethereum") or off-chain approvals.

```java
import java.nio.charset.StandardCharsets;

String message = "Hello Brane!";
Signature sig = signer.signMessage(message.getBytes(StandardCharsets.UTF_8));

System.out.println("Signature: " + sig);
```
