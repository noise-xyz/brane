---
title: Metrics & Observability
description: 'Integrate Brane with your monitoring stack.'
---

Brane provides hooks for collecting metrics from the RPC layer, enabling integration with Micrometer, Prometheus, Datadog, or custom monitoring solutions.

## BraneMetrics Interface

Implement the `BraneMetrics` interface to receive callbacks on RPC events:

```java
import io.brane.rpc.BraneMetrics;
import java.time.Duration;

public class MyMetrics implements BraneMetrics {
    
    @Override
    public void onRequestCompleted(String method, Duration latency) {
        // Record latency per method
    }
    
    @Override
    public void onRequestTimeout(String method) {
        // Increment timeout counter
    }
    
    @Override
    public void onBackpressure() {
        // Alert: too many pending requests
    }
}
```

---

## Wiring Up Metrics

Attach your metrics implementation to a WebSocket provider:

```java
import io.brane.rpc.WebSocketProvider;

var provider = WebSocketProvider.create("wss://...");
provider.setMetrics(new MyMetrics());
```

---

## Available Hooks

| Method | When Called | Use Case |
|--------|-------------|----------|
| `onRequestStarted(method)` | Request begins | Track in-flight requests |
| `onRequestCompleted(method, latency)` | Request succeeds | Latency histograms |
| `onRequestTimeout(method)` | Request times out | Timeout counters |
| `onRequestFailed(method, error)` | Request fails | Error rates |
| `onBackpressure()` | Too many pending requests | Backpressure alerts |
| `onConnectionLost()` | WebSocket disconnects | Connection health |
| `onReconnect()` | WebSocket reconnects | Reconnection tracking |
| `onSubscriptionNotification(id)` | Subscription event received | Subscription throughput |
| `onRingBufferSaturation(remaining, size)` | Buffer nearing capacity | Early warning |

---

## Micrometer Integration

Here's a complete example integrating with Micrometer:

```java
import io.brane.rpc.BraneMetrics;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.Timer;
import java.time.Duration;
import java.util.concurrent.ConcurrentHashMap;

public class MicrometerMetrics implements BraneMetrics {
    
    private final MeterRegistry registry;
    private final ConcurrentHashMap<String, Timer> timers = new ConcurrentHashMap<>();
    private final Counter backpressureCounter;
    private final Counter timeoutCounter;
    private final Counter reconnectCounter;
    
    public MicrometerMetrics(MeterRegistry registry) {
        this.registry = registry;
        this.backpressureCounter = registry.counter("brane.rpc.backpressure");
        this.timeoutCounter = registry.counter("brane.rpc.timeout");
        this.reconnectCounter = registry.counter("brane.rpc.reconnect");
    }
    
    @Override
    public void onRequestCompleted(String method, Duration latency) {
        Timer timer = timers.computeIfAbsent(method, m ->
            Timer.builder("brane.rpc.latency")
                .tag("method", m)
                .register(registry)
        );
        timer.record(latency);
    }
    
    @Override
    public void onRequestTimeout(String method) {
        timeoutCounter.increment();
        registry.counter("brane.rpc.timeout", "method", method).increment();
    }
    
    @Override
    public void onBackpressure() {
        backpressureCounter.increment();
    }
    
    @Override
    public void onReconnect() {
        reconnectCounter.increment();
    }
    
    @Override
    public void onRingBufferSaturation(long remaining, int size) {
        double pctFull = 1.0 - ((double) remaining / size);
        registry.gauge("brane.ringbuffer.saturation", pctFull);
    }
}
```

### Usage

```java
import io.micrometer.prometheus.PrometheusConfig;
import io.micrometer.prometheus.PrometheusMeterRegistry;

var registry = new PrometheusMeterRegistry(PrometheusConfig.DEFAULT);
var provider = WebSocketProvider.create("wss://...");
provider.setMetrics(new MicrometerMetrics(registry));

// Expose metrics at /metrics endpoint
// registry.scrape() returns Prometheus format
```

---

## Prometheus Metrics Example

With the Micrometer integration above, you'll get metrics like:

```prometheus
# TYPE brane_rpc_latency_seconds histogram
brane_rpc_latency_seconds_bucket{method="eth_blockNumber",le="0.01"} 1523
brane_rpc_latency_seconds_bucket{method="eth_blockNumber",le="0.05"} 2341
brane_rpc_latency_seconds_count{method="eth_blockNumber"} 2500

# TYPE brane_rpc_backpressure_total counter
brane_rpc_backpressure_total 3

# TYPE brane_rpc_timeout_total counter
brane_rpc_timeout_total{method="eth_getLogs"} 2
```

---

## Ring Buffer Saturation

The `onRingBufferSaturation` hook fires when the Disruptor ring buffer is less than 10% empty. This is an **early warning** of backpressure.

```java
@Override
public void onRingBufferSaturation(long remaining, int size) {
    double pctFull = 1.0 - ((double) remaining / size);
    log.warn("Ring buffer {}% full ({} slots remaining)", 
        (int)(pctFull * 100), remaining);
    
    // Consider: slow down request rate, alert on-call, etc.
}
```

<Tip>
`onRingBufferSaturation` is a leading indicator. `onBackpressure` means requests are already being rejected. Use saturation alerts to prevent backpressure.
</Tip>

---

## Simple Logging Implementation

For development or debugging, a simple logging implementation:

```java
import io.brane.rpc.BraneMetrics;
import java.time.Duration;

public class LoggingMetrics implements BraneMetrics {
    
    @Override
    public void onRequestCompleted(String method, Duration latency) {
        System.out.printf("[METRICS] %s completed in %dms%n", 
            method, latency.toMillis());
    }
    
    @Override
    public void onRequestTimeout(String method) {
        System.err.printf("[METRICS] %s timed out%n", method);
    }
    
    @Override
    public void onBackpressure() {
        System.err.println("[METRICS] Backpressure triggered!");
    }
    
    @Override
    public void onConnectionLost() {
        System.err.println("[METRICS] Connection lost");
    }
    
    @Override
    public void onReconnect() {
        System.out.println("[METRICS] Reconnected");
    }
}
```

---

## Thread Safety

All `BraneMetrics` methods may be called from multiple threads concurrently. Ensure your implementation is thread-safe:

- Use atomic counters or thread-safe collections
- Avoid blocking in callbacks (they're called from I/O threads)
- Micrometer's `MeterRegistry` is thread-safe by design

---

## Disabling Metrics

By default, a no-op implementation is used. You don't need to explicitly disable metricsâ€”just don't call `setMetrics()`.

```java
// No metrics collection (default)
var provider = WebSocketProvider.create("wss://...");

// With metrics
provider.setMetrics(new MyMetrics());
```
