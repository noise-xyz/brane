---
title: Error Handling
description: 'Handling RPC errors, contract reverts, and transaction failures.'
---

Brane provides a typed exception hierarchy to help you handle failures gracefully.

## Exception Hierarchy

All Brane exceptions extend `BraneException`, which is a sealed class:

```
BraneException (sealed root)
├── AbiDecodingException - ABI decoding failures
├── AbiEncodingException - ABI encoding failures
├── RevertException - EVM execution reverts
├── RpcException - JSON-RPC communication failures
└── TxnException - Transaction-specific failures (non-sealed)
    ├── BraneTxBuilderException - Transaction building failures
    ├── ChainMismatchException - Chain ID mismatch errors
    └── InvalidSenderException - Invalid sender address errors
```

### Catching All Brane Errors

```java
import io.brane.core.error.BraneException;

try {
    client.sendTransaction(request);
} catch (BraneException e) {
    // Catches any Brane SDK error
    System.err.println("Brane error: " + e.getMessage());
}
```

### Catching Specific Errors

```java
import io.brane.core.error.RevertException;
import io.brane.core.error.RpcException;
import io.brane.core.error.TxnException;

try {
    client.sendTransaction(request);
} catch (RevertException e) {
    // Contract execution reverted
    System.err.println("Reverted: " + e.revertReason());
} catch (RpcException e) {
    // Network/RPC error
    System.err.println("RPC Error: " + e.getMessage());
} catch (TxnException e) {
    // Transaction building/validation error
    System.err.println("Transaction Error: " + e.getMessage());
}
```

## RpcException

Thrown when the JSON-RPC node returns an error (e.g., rate limiting, invalid request).

```java
import io.brane.rpc.Brane;
import io.brane.core.types.Address;
import io.brane.core.error.RpcException;

Brane client = Brane.connect("https://eth.example.com");
Address address = Address.from("0x...");

try {
    client.getBalance(address);
} catch (RpcException e) {
    System.err.println("RPC Error: " + e.getMessage());
    System.err.println("Code: " + e.code());
}
```

## RevertException

Thrown when a smart contract execution reverts.

```java
import io.brane.rpc.Brane;
import io.brane.contract.BraneContract;
import io.brane.core.error.RevertException;

Brane.Signer client = Brane.connect("https://eth.example.com", signer);
MyToken token = BraneContract.bind(MyToken.class, abi, tokenAddress, client);

try {
    token.transfer(recipient, amount);
} catch (RevertException e) {
    System.err.println("Transaction Reverted: " + e.revertReason());
    // e.revertReason() automatically decodes standard string reverts
}
```

## ABI Exceptions

Thrown when ABI encoding or decoding fails.

```java
import io.brane.core.error.AbiEncodingException;
import io.brane.core.error.AbiDecodingException;

try {
    abi.encodeFunction("transfer", invalidArg);
} catch (AbiEncodingException e) {
    System.err.println("Encoding failed: " + e.getMessage());
}

try {
    abi.decodeFunction("balanceOf", malformedData);
} catch (AbiDecodingException e) {
    System.err.println("Decoding failed: " + e.getMessage());
}
```

## Transaction Exceptions

`TxnException` is the base for transaction-specific errors. Unlike other `BraneException` subtypes, it is **non-sealed** to allow for future extensibility.

### BraneTxBuilderException

Thrown when transaction building fails due to invalid parameters.

```java
import io.brane.core.builder.Eip1559Builder;
import io.brane.core.builder.BraneTxBuilderException;

try {
    // Missing required fields
    Eip1559Builder.create()
        .value(Wei.fromEther("1.0"))
        // Missing .to() and .data()
        .build(signer, client);
} catch (BraneTxBuilderException e) {
    System.err.println("Builder error: " + e.getMessage());
    // "Transaction must have a recipient or data"
}
```

### ChainMismatchException

Thrown when the transaction's chain ID doesn't match the connected network.

```java
import io.brane.core.error.ChainMismatchException;

try {
    // Trying to send a mainnet transaction to a testnet
    client.sendTransaction(mainnetTx);
} catch (ChainMismatchException e) {
    System.err.println("Wrong network: " + e.getMessage());
}
```

### InvalidSenderException

Thrown when the transaction sender address is invalid or doesn't match the signer.

```java
import io.brane.core.error.InvalidSenderException;

try {
    client.sendTransaction(txWithWrongSender);
} catch (InvalidSenderException e) {
    System.err.println("Invalid sender: " + e.getMessage());
}
```

## RPC-Layer Exceptions

The `io.brane.rpc.exception` package contains RPC-specific exceptions that are separate from the core `BraneException` hierarchy.

### RetryExhaustedException

Thrown when all retry attempts have been exhausted for transient RPC failures.

```java
import io.brane.rpc.exception.RetryExhaustedException;
import io.brane.core.error.RpcException;

try {
    client.getLatestBlock();
} catch (RetryExhaustedException e) {
    System.err.println("Failed after " + e.getAttemptCount() + " attempts");
    System.err.println("Total retry time: " + e.getTotalRetryDurationMs() + "ms");

    // Access all failed attempts
    for (Throwable suppressed : e.getSuppressed()) {
        System.err.println("  - " + suppressed.getMessage());
    }

    // Access original RPC error if available
    if (e.getCause() instanceof RpcException rpc) {
        System.err.println("RPC Error: " + rpc.code() + " - " + rpc.getMessage());
    }
}
```

### SimulateNotSupportedException

Thrown when `eth_simulateV1` is not supported by the RPC node. See [Transaction Simulation](/brane-reader/simulate) for details.

```java
import io.brane.rpc.exception.SimulateNotSupportedException;

try {
    client.simulate(request);
} catch (SimulateNotSupportedException e) {
    // Node does not support eth_simulateV1
    // Consider falling back to eth_call
    System.err.println(e.getMessage());
}
```

## Decoding Custom Errors

If your contract throws a custom error (e.g., `error InsufficientFunds(uint256 available, uint256 required)`), you can decode it using `RevertDecoder`.

```java
import io.brane.core.RevertDecoder;
import io.brane.core.abi.TypeSchema;
import io.brane.core.abi.Abi;
import io.brane.rpc.Brane;
import io.brane.contract.BraneContract;
import io.brane.core.error.RevertException;

Brane client = Brane.connect("https://eth.example.com");
MyToken token = BraneContract.bind(MyToken.class, abi, tokenAddress, client);

// 1. Define the Error Schema
var customError = new RevertDecoder.CustomErrorAbi(
    "InsufficientFunds",
    List.of(
        new TypeSchema.UIntSchema(256), // available
        new TypeSchema.UIntSchema(256)  // required
    )
);

// 2. Decode
try {
    token.balanceOf(address);
} catch (RevertException e) {
    String data = e.rawDataHex();
    String selector = Abi.getSelector("InsufficientFunds(uint256,uint256)");

    var decoded = RevertDecoder.decode(
        data,
        Map.of(selector, customError)
    );

    if (decoded.kind() == RevertDecoder.RevertKind.CUSTOM) {
        System.out.println("Custom Error: " + decoded.reason());
    }
}
```
