# EIP-712 Typed Data Signing Specification

> Type-safe EIP-712 implementation for Brane SDK using Java 21 patterns.

---

## Table of Contents

1. [Overview](#overview)
2. [EIP-712 Standard Summary](#eip-712-standard-summary)
3. [API Design](#api-design)
4. [Type System](#type-system)
5. [Encoding Implementation](#encoding-implementation)
6. [Integration Points](#integration-points)
7. [Error Handling](#error-handling)
8. [JSON Support](#json-support)
9. [Testing Strategy](#testing-strategy)
10. [Reference Implementations](#reference-implementations)

---

## Overview

### Goal

Implement EIP-712 typed data signing in Brane SDK, enabling:
- Signing structured data (e.g., Permit, Safe transactions, Uniswap orders)
- Type-safe domain and message construction
- Hash computation for verification without signing

### Scope

| In Scope | Out of Scope |
|----------|--------------|
| Domain separator computation | EIP-712 verification (contract-side) |
| Type hashing (encodeType, typeHash) | Recursive struct cycles |
| Struct hashing (encodeData, hashStruct) | Fixed-point decimals |
| signTypedData API | JSON schema generation |
| hashTypedData utility | |

### Module Location

`brane-core/src/main/java/io/brane/core/crypto/eip712/`

---

## EIP-712 Standard Summary

### Signing Formula

```
signature = sign(keccak256("\x19\x01" || domainSeparator || hashStruct(message)))
```

Where:
- `\x19\x01` - ERC-191 version byte + EIP-712 type byte
- `domainSeparator` - 32-byte hash identifying the dApp/protocol
- `hashStruct(message)` - 32-byte hash of the typed message

### Domain Separator

The `EIP712Domain` struct uniquely identifies a signing context:

| Field | Type | Purpose |
|-------|------|---------|
| `name` | string | DApp/protocol name |
| `version` | string | Signing domain version |
| `chainId` | uint256 | EIP-155 chain ID |
| `verifyingContract` | address | Contract that verifies signature |
| `salt` | bytes32 | Disambiguation salt (rare) |

All fields are optional. Include only what's needed.

### Type Encoding

**encodeType** produces a canonical string:
```
TypeName(type1 field1,type2 field2,...)
```

For nested types, dependencies are collected, sorted alphabetically, and appended:
```
Mail(Person from,Person to,string contents)Person(string name,address wallet)
```

**typeHash** = `keccak256(encodeType(typeName))`

### Data Encoding

**encodeData** concatenates 32-byte encoded values:

| Solidity Type | Encoding |
|---------------|----------|
| `uintN`, `intN` | Left-padded to 32 bytes |
| `address` | Left-padded to 32 bytes (20 bytes) |
| `bool` | `0x01` or `0x00`, left-padded |
| `bytesN` | Right-padded to 32 bytes |
| `bytes`, `string` | `keccak256(value)` |
| `Type[]`, `Type[n]` | `keccak256(concat(encodeData(elements)))` |
| Struct | `hashStruct(value)` (recursive) |

**hashStruct** = `keccak256(typeHash || encodeData(value))`

---

## API Design

### Design Philosophy

Brane SDK emphasizes type safety (`Address`, `Wei`, `Hash`, `HexData`). The EIP-712 API follows this philosophy:

- **Primary API**: Type-safe `TypedData<T>` with compile-time checked messages
- **Secondary API**: Map-based `TypedDataSigner` for dynamic use cases (JSON parsing, scripting)

### Primary API: Type-Safe `TypedData<T>`

```java
/**
 * Type-safe EIP-712 typed data container.
 * Provides compile-time safety for message structure.
 *
 * @param <T> the message type (typically a record)
 */
public final class TypedData<T> {

    /**
     * Creates typed data from a domain, type definition, and message.
     *
     * @param domain     the EIP-712 domain
     * @param definition the type definition with field mappings
     * @param message    the message instance
     * @return typed data ready for signing or hashing
     */
    public static <T> TypedData<T> create(
            Eip712Domain domain,
            TypeDefinition<T> definition,
            T message);

    /**
     * Computes the EIP-712 hash without signing.
     */
    public Hash hash();

    /**
     * Signs this typed data.
     *
     * @param signer the signer to use
     * @return signature with v=27 or v=28
     */
    public Signature sign(Signer signer);

    // Accessors
    public Eip712Domain domain();
    public String primaryType();
    public T message();
}

/**
 * Defines the EIP-712 type structure for a Java type.
 *
 * @param <T> the Java type this definition maps
 */
public record TypeDefinition<T>(
    String primaryType,
    Map<String, List<TypedDataField>> types,
    Function<T, Map<String, Object>> extractor
) {
    /**
     * Creates a definition for a record type using reflection.
     */
    public static <T extends Record> TypeDefinition<T> forRecord(
            Class<T> recordClass,
            String primaryType,
            Map<String, List<TypedDataField>> types);
}
```

**Example: ERC-2612 Permit (Type-Safe)**

```java
// Define the Permit record
record Permit(Address owner, Address spender, BigInteger value, BigInteger nonce, BigInteger deadline) {

    // Define the EIP-712 type structure once
    public static final TypeDefinition<Permit> DEFINITION = TypeDefinition.forRecord(
        Permit.class,
        "Permit",
        Map.of("Permit", List.of(
            TypedDataField.of("owner", "address"),
            TypedDataField.of("spender", "address"),
            TypedDataField.of("value", "uint256"),
            TypedDataField.of("nonce", "uint256"),
            TypedDataField.of("deadline", "uint256")
        ))
    );
}

// Usage - fully type-safe
var domain = Eip712Domain.builder()
    .name("MyToken")
    .version("1")
    .chainId(1L)
    .verifyingContract(tokenAddress)
    .build();

var permit = new Permit(owner, spender, value, nonce, deadline);
var typedData = TypedData.create(domain, Permit.DEFINITION, permit);

Signature sig = typedData.sign(signer);
Hash hash = typedData.hash();
```

### Secondary API: Dynamic `TypedDataSigner`

For dynamic use cases (JSON from dapps, scripting, runtime-generated types):

```java
public final class TypedDataSigner {
    private TypedDataSigner() {}

    /**
     * Signs typed data according to EIP-712.
     * Use this API when type structure is determined at runtime.
     *
     * @param domain      the EIP-712 domain
     * @param primaryType the name of the primary type being signed
     * @param types       all type definitions (including primaryType)
     * @param message     the message data as field name -> value map
     * @param signer      the signer to use
     * @return the signature with v=27 or v=28 for EIP-712 compatibility
     */
    public static Signature signTypedData(
            Eip712Domain domain,
            String primaryType,
            Map<String, List<TypedDataField>> types,
            Map<String, Object> message,
            Signer signer);

    /**
     * Computes the EIP-712 hash without signing.
     * Useful for verification or when signing happens externally.
     */
    public static Hash hashTypedData(
            Eip712Domain domain,
            String primaryType,
            Map<String, List<TypedDataField>> types,
            Map<String, Object> message);
}
```

### Domain Builder: `Eip712Domain`

```java
/**
 * EIP-712 domain separator fields.
 * All fields are optional - include only what your protocol uses.
 */
public record Eip712Domain(
    String name,
    String version,
    Long chainId,
    Address verifyingContract,
    Hash salt
) {
    public static Builder builder() { return new Builder(); }

    public static final class Builder {
        private String name;
        private String version;
        private Long chainId;
        private Address verifyingContract;
        private Hash salt;

        public Builder name(String name) { this.name = name; return this; }
        public Builder version(String version) { this.version = version; return this; }
        public Builder chainId(long chainId) { this.chainId = chainId; return this; }
        public Builder verifyingContract(Address addr) { this.verifyingContract = addr; return this; }
        public Builder salt(Hash salt) { this.salt = salt; return this; }
        public Eip712Domain build() {
            return new Eip712Domain(name, version, chainId, verifyingContract, salt);
        }
    }

    /**
     * Computes the domain separator hash.
     */
    public Hash separator() {
        return TypedDataEncoder.hashDomain(this);
    }
}
```

### Type Definition: `TypedDataField`

```java
/**
 * A single field in a struct type definition.
 *
 * @param name the field name
 * @param type the Solidity type (e.g., "address", "uint256", "Person")
 */
public record TypedDataField(String name, String type) {
    public TypedDataField {
        Objects.requireNonNull(name, "name");
        Objects.requireNonNull(type, "type");
        if (name.isBlank()) throw new IllegalArgumentException("name cannot be blank");
        if (type.isBlank()) throw new IllegalArgumentException("type cannot be blank");
    }

    public static TypedDataField of(String name, String type) {
        return new TypedDataField(name, type);
    }
}
```

---

## Type System

### Class Hierarchy

```
io.brane.core.crypto.eip712/
├── Eip712Domain.java           # Domain separator record + builder
├── Eip712Type.java             # Sealed interface for type representation
├── Eip712TypeParser.java       # Solidity type string parsing
├── Eip712Exception.java        # EIP-712 specific exceptions (extends BraneException)
├── TypedData.java              # Type-safe typed data container (PRIMARY API)
├── TypeDefinition.java         # Type structure definition for Java types
├── TypedDataField.java         # Field definition (name, type)
├── TypedDataSigner.java        # Dynamic signing API (SECONDARY)
├── TypedDataEncoder.java       # Internal encoding logic
├── TypedDataJson.java          # JSON parsing (eth_signTypedData_v4 format)
├── TypedDataPayload.java       # Raw JSON payload record
└── ValueCoercer.java           # Internal value type coercion for JSON
```

### Supported Solidity Types

| Category | Types |
|----------|-------|
| Integers | `uint8`-`uint256`, `int8`-`int256` |
| Address | `address` |
| Boolean | `bool` |
| Fixed bytes | `bytes1`-`bytes32` |
| Dynamic | `bytes`, `string` |
| Arrays | `Type[]`, `Type[N]` |
| Structs | Custom struct types |

### Type Resolution

```java
sealed interface Eip712Type permits
    Eip712Type.Uint,
    Eip712Type.Int,
    Eip712Type.Address,
    Eip712Type.Bool,
    Eip712Type.FixedBytes,
    Eip712Type.DynamicBytes,
    Eip712Type.String,
    Eip712Type.Array,
    Eip712Type.Struct {

    record Uint(int bits) implements Eip712Type {
        public Uint {
            if (bits % 8 != 0 || bits < 8 || bits > 256) {
                throw new IllegalArgumentException("Invalid uint width: " + bits);
            }
        }
    }
    record Int(int bits) implements Eip712Type {
        public Int {
            if (bits % 8 != 0 || bits < 8 || bits > 256) {
                throw new IllegalArgumentException("Invalid int width: " + bits);
            }
        }
    }
    record Address() implements Eip712Type {}
    record Bool() implements Eip712Type {}
    record FixedBytes(int length) implements Eip712Type {
        public FixedBytes {
            if (length < 1 || length > 32) {
                throw new IllegalArgumentException("Invalid bytes length: " + length);
            }
        }
    }
    record DynamicBytes() implements Eip712Type {}
    record String() implements Eip712Type {}
    record Array(Eip712Type elementType, Integer fixedLength) implements Eip712Type {}
    record Struct(java.lang.String name) implements Eip712Type {}
}
```

### Type Parsing

Converts Solidity type strings to `Eip712Type` instances:

```java
final class Eip712TypeParser {
    private Eip712TypeParser() {}

    // Regex patterns for type parsing
    private static final Pattern UINT_PATTERN = Pattern.compile("^uint(\\d*)$");
    private static final Pattern INT_PATTERN = Pattern.compile("^int(\\d*)$");
    private static final Pattern FIXED_BYTES_PATTERN = Pattern.compile("^bytes(\\d+)$");
    private static final Pattern FIXED_ARRAY_PATTERN = Pattern.compile("^(.+)\\[(\\d+)\\]$");
    private static final Pattern DYNAMIC_ARRAY_PATTERN = Pattern.compile("^(.+)\\[\\]$");

    /**
     * Parses a Solidity type string into an Eip712Type.
     *
     * @param type  the Solidity type string (e.g., "uint256", "address", "bytes32[]")
     * @param types the type definitions (for resolving struct types)
     * @return the parsed Eip712Type
     * @throws Eip712Exception if the type is unknown or invalid
     */
    static Eip712Type parse(String type, Map<String, List<TypedDataField>> types) {
        Objects.requireNonNull(type, "type");
        Objects.requireNonNull(types, "types");

        // Check for dynamic array suffix: "uint256[]"
        var dynamicArrayMatch = DYNAMIC_ARRAY_PATTERN.matcher(type);
        if (dynamicArrayMatch.matches()) {
            String elementType = dynamicArrayMatch.group(1);
            return new Eip712Type.Array(parse(elementType, types), null);
        }

        // Check for fixed-size array: "bytes32[10]"
        var fixedArrayMatch = FIXED_ARRAY_PATTERN.matcher(type);
        if (fixedArrayMatch.matches()) {
            String elementType = fixedArrayMatch.group(1);
            int size = Integer.parseInt(fixedArrayMatch.group(2));
            if (size <= 0) {
                throw Eip712Exception.invalidValue(type, "array size must be positive");
            }
            return new Eip712Type.Array(parse(elementType, types), size);
        }

        // Check for uint with bit width: "uint256", "uint8", "uint"
        var uintMatch = UINT_PATTERN.matcher(type);
        if (uintMatch.matches()) {
            String bitsStr = uintMatch.group(1);
            int bits = bitsStr.isEmpty() ? 256 : Integer.parseInt(bitsStr);
            return new Eip712Type.Uint(bits);
        }

        // Check for int with bit width: "int256", "int8", "int"
        var intMatch = INT_PATTERN.matcher(type);
        if (intMatch.matches()) {
            String bitsStr = intMatch.group(1);
            int bits = bitsStr.isEmpty() ? 256 : Integer.parseInt(bitsStr);
            return new Eip712Type.Int(bits);
        }

        // Check for fixed bytes: "bytes1" through "bytes32"
        var fixedBytesMatch = FIXED_BYTES_PATTERN.matcher(type);
        if (fixedBytesMatch.matches()) {
            int length = Integer.parseInt(fixedBytesMatch.group(1));
            return new Eip712Type.FixedBytes(length);
        }

        // Primitive types
        return switch (type) {
            case "address" -> new Eip712Type.Address();
            case "bool" -> new Eip712Type.Bool();
            case "bytes" -> new Eip712Type.DynamicBytes();
            case "string" -> new Eip712Type.String();
            default -> {
                // Must be a custom struct type - verify it exists in types map
                if (!types.containsKey(type)) {
                    throw Eip712Exception.unknownType(type);
                }
                yield new Eip712Type.Struct(type);
            }
        };
    }

    /**
     * Converts an Eip712Type back to its Solidity type string.
     */
    static String toSolidityType(Eip712Type type) {
        return switch (type) {
            case Eip712Type.Uint u -> "uint" + u.bits();
            case Eip712Type.Int i -> "int" + i.bits();
            case Eip712Type.Address a -> "address";
            case Eip712Type.Bool b -> "bool";
            case Eip712Type.FixedBytes fb -> "bytes" + fb.length();
            case Eip712Type.DynamicBytes db -> "bytes";
            case Eip712Type.String s -> "string";
            case Eip712Type.Array arr -> {
                String base = toSolidityType(arr.elementType());
                yield arr.fixedLength() != null
                    ? base + "[" + arr.fixedLength() + "]"
                    : base + "[]";
            }
            case Eip712Type.Struct struct -> struct.name();
        };
    }
}
```

---

## Encoding Implementation

### TypedDataEncoder (Internal)

```java
final class TypedDataEncoder {
    private TypedDataEncoder() {}

    // ═══════════════════════════════════════════════════════════════
    // TYPE ENCODING
    // ═══════════════════════════════════════════════════════════════

    /**
     * Encodes a type definition to its canonical string form.
     * Example: "Mail(Person from,Person to,string contents)Person(string name,address wallet)"
     *
     * <p>This follows viem's implementation pattern:
     * <ol>
     *   <li>Collect ALL dependencies recursively</li>
     *   <li>Sort dependencies alphabetically (primary type first)</li>
     *   <li>Format each type string (NO recursion in formatting)</li>
     * </ol>
     */
    static String encodeType(
            String typeName,
            Map<String, List<TypedDataField>> types) {

        // Phase 1: Collect ALL dependencies recursively with cycle detection
        Set<String> allDeps = new LinkedHashSet<>();
        Set<String> visiting = new HashSet<>();
        collectDependencies(typeName, types, allDeps, visiting);

        // Phase 2: Sort - primary type first, then remaining alphabetically
        List<String> sortedTypes = new ArrayList<>();
        sortedTypes.add(typeName);
        allDeps.remove(typeName);
        allDeps.stream().sorted().forEach(sortedTypes::add);

        // Phase 3: Format each type (NO recursion - just string formatting)
        var result = new StringBuilder();
        for (String t : sortedTypes) {
            result.append(formatSingleType(t, types));
        }

        return result.toString();
    }

    /**
     * Formats a single type definition without recursion.
     * Output: "TypeName(type1 field1,type2 field2,...)"
     */
    private static String formatSingleType(
            String typeName,
            Map<String, List<TypedDataField>> types) {
        var fields = types.get(typeName);
        var sb = new StringBuilder();
        sb.append(typeName).append("(");
        for (int i = 0; i < fields.size(); i++) {
            if (i > 0) sb.append(",");
            var field = fields.get(i);
            sb.append(field.type()).append(" ").append(field.name());
        }
        sb.append(")");
        return sb.toString();
    }

    /**
     * Recursively collects all struct type dependencies.
     *
     * @param typeName the type to collect dependencies for
     * @param types    all type definitions
     * @param deps     accumulator for dependencies found
     * @param visiting types currently being visited (for cycle detection)
     * @throws Eip712Exception if a cyclic dependency is detected
     */
    private static void collectDependencies(
            String typeName,
            Map<String, List<TypedDataField>> types,
            Set<String> deps,
            Set<String> visiting) {

        // Cycle detection
        if (visiting.contains(typeName)) {
            throw Eip712Exception.cyclicDependency(typeName);
        }

        var fields = types.get(typeName);
        if (fields == null) {
            return;  // Not a struct type (primitive)
        }

        // Add this type and mark as visiting
        deps.add(typeName);
        visiting.add(typeName);

        // Recurse into field types
        for (var field : fields) {
            String baseType = getBaseType(field.type());  // Strip [] suffix
            if (types.containsKey(baseType)) {
                collectDependencies(baseType, types, deps, visiting);
            }
        }

        // Done visiting this type
        visiting.remove(typeName);
    }

    /**
     * Extracts the base type from a potentially array type.
     * "uint256[]" -> "uint256", "Person[3]" -> "Person", "address" -> "address"
     */
    private static String getBaseType(String type) {
        int bracketIdx = type.indexOf('[');
        return bracketIdx >= 0 ? type.substring(0, bracketIdx) : type;
    }

    /**
     * Computes typeHash = keccak256(encodeType(typeName))
     */
    static byte[] typeHash(
            String typeName,
            Map<String, List<TypedDataField>> types) {
        var encoded = encodeType(typeName, types);
        return Keccak256.hash(encoded.getBytes(StandardCharsets.UTF_8));
    }

    // ═══════════════════════════════════════════════════════════════
    // DATA ENCODING
    // ═══════════════════════════════════════════════════════════════

    /**
     * Encodes struct data according to EIP-712.
     * Returns concatenated 32-byte encoded field values.
     */
    static byte[] encodeData(
            String typeName,
            Map<String, List<TypedDataField>> types,
            Map<String, Object> data) {
        var fields = types.get(typeName);
        var encoded = new ByteArrayOutputStream();

        for (var field : fields) {
            var value = data.get(field.name());
            var fieldEncoded = encodeField(field.type(), value, types);
            encoded.writeBytes(fieldEncoded);
        }

        return encoded.toByteArray();
    }

    /**
     * Encodes a single field value based on its type.
     * Uses Eip712TypeParser to resolve the type string.
     */
    static byte[] encodeField(
            String type,
            Object value,
            Map<String, List<TypedDataField>> types) {
        Eip712Type parsedType = Eip712TypeParser.parse(type, types);
        return switch (parsedType) {
            case Eip712Type.Uint u -> encodeUint(value, u.bits());
            case Eip712Type.Int i -> encodeInt(value, i.bits());
            case Eip712Type.Address a -> encodeAddress(value);
            case Eip712Type.Bool b -> encodeBool(value);
            case Eip712Type.FixedBytes fb -> encodeFixedBytes(value, fb.length());
            case Eip712Type.DynamicBytes db -> encodeDynamicBytes(value);
            case Eip712Type.String s -> encodeString(value);
            case Eip712Type.Array arr -> encodeArray(arr, value, types);
            case Eip712Type.Struct struct -> hashStruct(struct.name(), types, asMap(value));
        };
    }

    // ═══════════════════════════════════════════════════════════════
    // STRUCT HASHING
    // ═══════════════════════════════════════════════════════════════

    /**
     * hashStruct(s) = keccak256(typeHash || encodeData(s))
     */
    static byte[] hashStruct(
            String typeName,
            Map<String, List<TypedDataField>> types,
            Map<String, Object> data) {
        var typeHashBytes = typeHash(typeName, types);
        var encodedData = encodeData(typeName, types, data);
        return Keccak256.hash(typeHashBytes, encodedData);
    }

    // ═══════════════════════════════════════════════════════════════
    // DOMAIN HASHING
    // ═══════════════════════════════════════════════════════════════

    /**
     * Computes domain separator from Eip712Domain.
     */
    static Hash hashDomain(Eip712Domain domain) {
        var types = buildDomainTypes(domain);
        var data = buildDomainData(domain);
        var hash = hashStruct("EIP712Domain", types, data);
        return Hash.fromBytes(hash);
    }

    private static Map<String, List<TypedDataField>> buildDomainTypes(Eip712Domain domain) {
        var fields = new ArrayList<TypedDataField>();
        if (domain.name() != null) fields.add(TypedDataField.of("name", "string"));
        if (domain.version() != null) fields.add(TypedDataField.of("version", "string"));
        if (domain.chainId() != null) fields.add(TypedDataField.of("chainId", "uint256"));
        if (domain.verifyingContract() != null) fields.add(TypedDataField.of("verifyingContract", "address"));
        if (domain.salt() != null) fields.add(TypedDataField.of("salt", "bytes32"));
        return Map.of("EIP712Domain", fields);
    }
}
```

### Primitive Encoding Details

```java
// uint encoding: left-pad to 32 bytes, big-endian
static byte[] encodeUint(Object value, int bits) {
    BigInteger bi = toBigInteger(value);
    if (bi.signum() < 0) {
        throw new TypedDataException("uint cannot be negative: " + bi);
    }
    if (bi.bitLength() > bits) {
        throw new TypedDataException("value exceeds uint" + bits + ": " + bi);
    }
    return padLeft(bi.toByteArray(), 32);
}

// address encoding: 20 bytes left-padded to 32
static byte[] encodeAddress(Object value) {
    Address addr = toAddress(value);
    byte[] bytes = addr.toBytes(); // 20 bytes
    return padLeft(bytes, 32);
}

// string/bytes encoding: keccak256(value)
static byte[] encodeString(Object value) {
    String str = (String) value;
    return Keccak256.hash(str.getBytes(StandardCharsets.UTF_8));
}

static byte[] encodeDynamicBytes(Object value) {
    byte[] bytes = toBytes(value);
    return Keccak256.hash(bytes);
}

// array encoding: keccak256(concat(encoded elements))
static byte[] encodeArray(Eip712Type.Array arr, Object value, Map<String, List<TypedDataField>> types) {
    List<?> list = (List<?>) value;
    var encoded = new ByteArrayOutputStream();
    String elementType = arr.elementType() instanceof Eip712Type.Struct s
        ? s.name()
        : toSolidityType(arr.elementType());
    for (var item : list) {
        encoded.writeBytes(encodeField(elementType, item, types));
    }
    return Keccak256.hash(encoded.toByteArray());
}
```

---

## Integration Points

### Signer Interface Extension

Add to existing `Signer` interface:

```java
public interface Signer {
    Address address();
    Signature signTransaction(UnsignedTransaction tx, long chainId);
    Signature signMessage(byte[] message);  // EIP-191

    /**
     * Signs typed data according to EIP-712.
     *
     * @param domain      the EIP-712 domain
     * @param primaryType the primary type name
     * @param types       type definitions
     * @param message     message data
     * @return signature with v=27 or v=28
     */
    default Signature signTypedData(
            Eip712Domain domain,
            String primaryType,
            Map<String, List<TypedDataField>> types,
            Map<String, Object> message) {
        return TypedDataSigner.signTypedData(domain, primaryType, types, message, this);
    }
}
```

### PrivateKeySigner Implementation

```java
public final class PrivateKeySigner implements Signer {
    // ... existing code ...

    @Override
    public Signature signTypedData(
            Eip712Domain domain,
            String primaryType,
            Map<String, List<TypedDataField>> types,
            Map<String, Object> message) {

        // Compute domain separator and struct hash
        byte[] domainSeparator = TypedDataEncoder.hashDomain(domain).toBytes();
        byte[] structHash = TypedDataEncoder.hashStruct(primaryType, types, message);

        // Final hash: keccak256("\x19\x01" || domainSeparator || structHash)
        // Using Keccak256 multi-arg to avoid intermediate allocations
        byte[] finalHash = Keccak256.hash(
            new byte[]{0x19, 0x01},  // EIP-712 prefix
            domainSeparator,
            structHash
        );

        // Sign using signFast for consistency with signMessage
        // signFast returns v=0 or v=1 (recovery ID)
        Signature sig = privateKey.signFast(finalHash);

        // Adjust v to 27 or 28 for EIP-712/EIP-191 compatibility
        return new Signature(sig.r(), sig.s(), sig.v() + 27);
    }
}
```

**Implementation Notes:**
- Uses `Keccak256.hash(byte[]...)` multi-arg form to avoid allocating intermediate byte arrays
- Uses `signFast()` instead of `sign()` for consistency with existing `signMessage()` implementation
- The v adjustment (`+ 27`) converts recovery ID (0 or 1) to EIP-712 format (27 or 28)

### Usage Example: ERC-2612 Permit

```java
// Build domain
var domain = Eip712Domain.builder()
    .name("MyToken")
    .version("1")
    .chainId(1L)
    .verifyingContract(tokenAddress)
    .build();

// Define types
var types = Map.of(
    "Permit", List.of(
        TypedDataField.of("owner", "address"),
        TypedDataField.of("spender", "address"),
        TypedDataField.of("value", "uint256"),
        TypedDataField.of("nonce", "uint256"),
        TypedDataField.of("deadline", "uint256")
    )
);

// Build message
var message = Map.of(
    "owner", ownerAddress,
    "spender", spenderAddress,
    "value", BigInteger.valueOf(1000),
    "nonce", BigInteger.ZERO,
    "deadline", BigInteger.valueOf(System.currentTimeMillis() / 1000 + 3600)
);

// Sign
Signature sig = signer.signTypedData(domain, "Permit", types, message);
```

### Usage Example: Safe Transaction

```java
var domain = Eip712Domain.builder()
    .chainId(1L)
    .verifyingContract(safeAddress)
    .build();

var types = Map.of(
    "SafeTx", List.of(
        TypedDataField.of("to", "address"),
        TypedDataField.of("value", "uint256"),
        TypedDataField.of("data", "bytes"),
        TypedDataField.of("operation", "uint8"),
        TypedDataField.of("safeTxGas", "uint256"),
        TypedDataField.of("baseGas", "uint256"),
        TypedDataField.of("gasPrice", "uint256"),
        TypedDataField.of("gasToken", "address"),
        TypedDataField.of("refundReceiver", "address"),
        TypedDataField.of("nonce", "uint256")
    )
);

var message = Map.of(
    "to", recipient,
    "value", Wei.fromEther("1").toBigInteger(),
    "data", HexData.empty(),
    // ... other fields
);

Signature sig = signer.signTypedData(domain, "SafeTx", types, message);
```

---

## Error Handling

### Exception Hierarchy

`Eip712Exception` extends `BraneException` directly and is added to the sealed permits list.
This is required because `AbiEncodingException` is declared `final` and cannot be extended.

```
BraneException (sealed)
├── AbiDecodingException (final)
├── AbiEncodingException (final)
├── Eip712Exception (final)  ← NEW: added to permits list
├── RevertException (final)
├── RpcException (non-sealed)
└── TxnException (non-sealed)
```

**Why not extend AbiEncodingException?**
- `AbiEncodingException` is `final` (cannot be subclassed)
- EIP-712 is semantically distinct from ABI encoding (structured data signing vs. function call encoding)
- Direct extension from `BraneException` allows catch blocks like `catch (BraneException e)` to handle EIP-712 errors

```java
/**
 * Exception for EIP-712 encoding and validation failures.
 *
 * <p>Extends BraneException directly as AbiEncodingException is final.
 * EIP-712 is semantically distinct from ABI encoding - it's a structured
 * data signing format rather than function call encoding.
 */
public final class Eip712Exception extends BraneException {

    public Eip712Exception(String message) {
        super(message);
    }

    public Eip712Exception(String message, Throwable cause) {
        super(message, cause);
    }

    // ═══════════════════════════════════════════════════════════════
    // Factory methods for specific error conditions
    // ═══════════════════════════════════════════════════════════════

    /**
     * Type string references an unknown type not in the types map.
     */
    public static Eip712Exception unknownType(String type) {
        return new Eip712Exception("Unknown EIP-712 type: " + type);
    }

    /**
     * Required field is missing from the message data.
     */
    public static Eip712Exception missingField(String typeName, String fieldName) {
        return new Eip712Exception(
            "Missing field '%s' in type '%s'".formatted(fieldName, typeName));
    }

    /**
     * Value cannot be encoded as the specified type.
     */
    public static Eip712Exception invalidValue(String type, Object value) {
        return new Eip712Exception(
            "Invalid value for type '%s': %s".formatted(type, value));
    }

    /**
     * Cyclic dependency detected in type definitions.
     */
    public static Eip712Exception cyclicDependency(String typeName) {
        return new Eip712Exception("Cyclic type dependency at: " + typeName);
    }

    /**
     * Value exceeds the valid range for the type.
     */
    public static Eip712Exception valueOutOfRange(String type, Object value, String reason) {
        return new Eip712Exception(
            "Value out of range for '%s': %s (%s)".formatted(type, value, reason));
    }

    /**
     * Primary type not found in types map.
     */
    public static Eip712Exception primaryTypeNotFound(String primaryType) {
        return new Eip712Exception("Primary type not found: " + primaryType);
    }
}
```

### Validation Rules

| Rule | Error |
|------|-------|
| Unknown type in field | `Eip712Exception.unknownType(type)` |
| Missing field in message | `Eip712Exception.missingField(type, field)` |
| Value doesn't match type | `Eip712Exception.invalidValue(type, value)` |
| Cyclic struct reference | `Eip712Exception.cyclicDependency(type)` |
| uint negative value | `Eip712Exception.valueOutOfRange("uint", value, "must be non-negative")` |
| Value exceeds bit width | `Eip712Exception.valueOutOfRange("uint" + bits, value, "exceeds bit width")` |
| Primary type not in types | `Eip712Exception.primaryTypeNotFound(primaryType)` |

---

## JSON Support

Real-world EIP-712 data often arrives as JSON from dapps (WalletConnect, browser extensions).
This section defines JSON parsing support compatible with `eth_signTypedData_v4`.

### TypedDataJson Parser

```java
/**
 * JSON parsing support for EIP-712 typed data.
 * Compatible with eth_signTypedData_v4 JSON format used by MetaMask, WalletConnect, etc.
 */
public final class TypedDataJson {
    private static final ObjectMapper MAPPER = createMapper();

    private TypedDataJson() {}

    /**
     * Parses EIP-712 typed data from JSON string.
     *
     * @param json the JSON string in eth_signTypedData_v4 format
     * @return parsed typed data payload
     * @throws Eip712Exception if JSON is invalid or missing required fields
     */
    public static TypedDataPayload parse(String json) {
        try {
            return MAPPER.readValue(json, TypedDataPayload.class);
        } catch (JsonProcessingException e) {
            throw new Eip712Exception("Invalid EIP-712 JSON: " + e.getMessage(), e);
        }
    }

    /**
     * Parses and validates typed data, then creates a signable TypedData instance.
     */
    public static TypedData<?> parseAndValidate(String json) {
        TypedDataPayload payload = parse(json);
        return TypedData.fromPayload(payload);
    }

    private static ObjectMapper createMapper() {
        return new ObjectMapper()
            .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
    }
}

/**
 * Raw typed data payload parsed from JSON.
 * Mirrors the eth_signTypedData_v4 request format.
 */
public record TypedDataPayload(
    @JsonProperty("domain") Eip712Domain domain,
    @JsonProperty("primaryType") String primaryType,
    @JsonProperty("types") Map<String, List<TypedDataField>> types,
    @JsonProperty("message") Map<String, Object> message
) {
    public TypedDataPayload {
        Objects.requireNonNull(primaryType, "primaryType");
        Objects.requireNonNull(types, "types");
        Objects.requireNonNull(message, "message");
        if (!types.containsKey(primaryType)) {
            throw Eip712Exception.primaryTypeNotFound(primaryType);
        }
    }
}
```

### JSON Format (eth_signTypedData_v4)

```json
{
  "domain": {
    "name": "MyToken",
    "version": "1",
    "chainId": 1,
    "verifyingContract": "0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC"
  },
  "primaryType": "Permit",
  "types": {
    "EIP712Domain": [
      { "name": "name", "type": "string" },
      { "name": "version", "type": "string" },
      { "name": "chainId", "type": "uint256" },
      { "name": "verifyingContract", "type": "address" }
    ],
    "Permit": [
      { "name": "owner", "type": "address" },
      { "name": "spender", "type": "address" },
      { "name": "value", "type": "uint256" },
      { "name": "nonce", "type": "uint256" },
      { "name": "deadline", "type": "uint256" }
    ]
  },
  "message": {
    "owner": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "spender": "0x70997970C51812dc3A010C7d01b50e0d17dc79C8",
    "value": "1000000000000000000",
    "nonce": "0",
    "deadline": "1714521600"
  }
}
```

### Usage Example

```java
// Parse JSON from dapp request
String jsonFromDapp = walletConnectRequest.getTypedData();
TypedDataPayload payload = TypedDataJson.parse(jsonFromDapp);

// Sign using the secondary (dynamic) API
Signature sig = TypedDataSigner.signTypedData(
    payload.domain(),
    payload.primaryType(),
    payload.types(),
    payload.message(),
    signer
);

// Or use the convenience method
TypedData<?> typedData = TypedDataJson.parseAndValidate(jsonFromDapp);
Signature sig = typedData.sign(signer);
```

### Value Type Handling

JSON values are coerced to appropriate Java types:

| JSON Type | Solidity Type | Java Type |
|-----------|---------------|-----------|
| String (hex) | `address` | `Address` |
| String (hex) | `bytes`, `bytesN` | `HexData` |
| String (numeric) | `uint256`, `int256` | `BigInteger` |
| Number | `uint8`-`uint64` | `BigInteger` |
| Boolean | `bool` | `Boolean` |
| String | `string` | `String` |
| Array | `Type[]` | `List<?>` |
| Object | Struct | `Map<String, Object>` |

### Value Coercion Implementation

```java
/**
 * Coerces JSON-parsed values to the appropriate Java types for EIP-712 encoding.
 * Called during encoding to ensure values match expected types.
 */
final class ValueCoercer {
    private ValueCoercer() {}

    static Object coerce(Object value, Eip712Type type) {
        if (value == null) {
            throw Eip712Exception.invalidValue(Eip712TypeParser.toSolidityType(type), null);
        }

        return switch (type) {
            case Eip712Type.Address a -> coerceAddress(value);
            case Eip712Type.Uint u -> coerceUint(value, u.bits());
            case Eip712Type.Int i -> coerceInt(value, i.bits());
            case Eip712Type.Bool b -> coerceBool(value);
            case Eip712Type.FixedBytes fb -> coerceFixedBytes(value, fb.length());
            case Eip712Type.DynamicBytes db -> coerceDynamicBytes(value);
            case Eip712Type.String s -> coerceString(value);
            case Eip712Type.Array arr -> coerceArray(value, arr);
            case Eip712Type.Struct struct -> coerceStruct(value);
        };
    }

    private static Address coerceAddress(Object value) {
        if (value instanceof Address addr) return addr;
        if (value instanceof String s) return Address.from(s);
        throw Eip712Exception.invalidValue("address", value);
    }

    private static BigInteger coerceUint(Object value, int bits) {
        BigInteger bi = toBigInteger(value);
        if (bi.signum() < 0) {
            throw Eip712Exception.valueOutOfRange("uint" + bits, bi, "must be non-negative");
        }
        if (bi.bitLength() > bits) {
            throw Eip712Exception.valueOutOfRange("uint" + bits, bi, "exceeds bit width");
        }
        return bi;
    }

    private static BigInteger coerceInt(Object value, int bits) {
        BigInteger bi = toBigInteger(value);
        BigInteger max = BigInteger.ONE.shiftLeft(bits - 1).subtract(BigInteger.ONE);
        BigInteger min = max.negate().subtract(BigInteger.ONE);
        if (bi.compareTo(min) < 0 || bi.compareTo(max) > 0) {
            throw Eip712Exception.valueOutOfRange("int" + bits, bi, "out of signed range");
        }
        return bi;
    }

    private static BigInteger toBigInteger(Object value) {
        if (value instanceof BigInteger bi) return bi;
        if (value instanceof Number n) return BigInteger.valueOf(n.longValue());
        if (value instanceof String s) {
            // Handle both decimal and hex strings
            if (s.startsWith("0x") || s.startsWith("0X")) {
                return new BigInteger(s.substring(2), 16);
            }
            return new BigInteger(s);
        }
        throw Eip712Exception.invalidValue("integer", value);
    }

    private static Boolean coerceBool(Object value) {
        if (value instanceof Boolean b) return b;
        if (value instanceof String s) return Boolean.parseBoolean(s);
        throw Eip712Exception.invalidValue("bool", value);
    }

    private static HexData coerceFixedBytes(Object value, int length) {
        HexData data = toHexData(value);
        if (data.toBytes().length != length) {
            throw Eip712Exception.valueOutOfRange(
                "bytes" + length, value,
                "expected " + length + " bytes, got " + data.toBytes().length);
        }
        return data;
    }

    private static HexData coerceDynamicBytes(Object value) {
        return toHexData(value);
    }

    private static HexData toHexData(Object value) {
        if (value instanceof HexData hd) return hd;
        if (value instanceof byte[] bytes) return HexData.from(bytes);
        if (value instanceof String s) return HexData.from(s);
        throw Eip712Exception.invalidValue("bytes", value);
    }

    private static String coerceString(Object value) {
        if (value instanceof String s) return s;
        throw Eip712Exception.invalidValue("string", value);
    }

    @SuppressWarnings("unchecked")
    private static List<?> coerceArray(Object value, Eip712Type.Array arr) {
        if (!(value instanceof List<?> list)) {
            throw Eip712Exception.invalidValue("array", value);
        }
        if (arr.fixedLength() != null && list.size() != arr.fixedLength()) {
            throw Eip712Exception.valueOutOfRange(
                "array[" + arr.fixedLength() + "]", value,
                "expected " + arr.fixedLength() + " elements, got " + list.size());
        }
        // Elements are coerced during encoding
        return list;
    }

    @SuppressWarnings("unchecked")
    private static Map<String, Object> coerceStruct(Object value) {
        if (value instanceof Map<?, ?> map) {
            return (Map<String, Object>) map;
        }
        throw Eip712Exception.invalidValue("struct", value);
    }
}
```

---

## Testing Strategy

### Unit Tests

```java
class TypedDataEncoderTest {

    @Test
    void encodeType_simpleStruct() {
        var types = Map.of(
            "Person", List.of(
                TypedDataField.of("name", "string"),
                TypedDataField.of("wallet", "address")
            )
        );
        String encoded = TypedDataEncoder.encodeType("Person", types);
        assertEquals("Person(string name,address wallet)", encoded);
    }

    @Test
    void encodeType_withNestedStruct() {
        var types = Map.of(
            "Mail", List.of(
                TypedDataField.of("from", "Person"),
                TypedDataField.of("to", "Person"),
                TypedDataField.of("contents", "string")
            ),
            "Person", List.of(
                TypedDataField.of("name", "string"),
                TypedDataField.of("wallet", "address")
            )
        );
        String encoded = TypedDataEncoder.encodeType("Mail", types);
        assertEquals(
            "Mail(Person from,Person to,string contents)Person(string name,address wallet)",
            encoded
        );
    }

    @Test
    void typeHash_matchesExpected() {
        // From EIP-712 example
        var types = Map.of(
            "Person", List.of(
                TypedDataField.of("name", "string"),
                TypedDataField.of("wallet", "address")
            )
        );
        byte[] hash = TypedDataEncoder.typeHash("Person", types);
        assertEquals(
            "0xb9d8c78acf9b987311de6c7b45bb6a9c8e1bf361fa7fd3467a2163f994c79500",
            Hex.encode(hash)
        );
    }

    @Test
    void hashStruct_matchesEip712Example() {
        // Use official EIP-712 test vectors
        // ...
    }
}
```

### Integration Tests

```java
class TypedDataSignerIntegrationTest {

    private static final PrivateKey TEST_KEY = PrivateKey.fromHex(
        "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80"
    );

    @Test
    void signTypedData_permit_matchesEthersJs() {
        // Compare signature output with ethers.js/viem
        var domain = Eip712Domain.builder()
            .name("MyToken")
            .version("1")
            .chainId(1L)
            .verifyingContract(Address.from("0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC"))
            .build();

        var types = Map.of(
            "Permit", List.of(
                TypedDataField.of("owner", "address"),
                TypedDataField.of("spender", "address"),
                TypedDataField.of("value", "uint256"),
                TypedDataField.of("nonce", "uint256"),
                TypedDataField.of("deadline", "uint256")
            )
        );

        var message = Map.of(
            "owner", Address.from("0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"),
            "spender", Address.from("0x70997970C51812dc3A010C7d01b50e0d17dc79C8"),
            "value", BigInteger.valueOf(1000000000000000000L),
            "nonce", BigInteger.ZERO,
            "deadline", BigInteger.valueOf(1714521600L)
        );

        Signer signer = new PrivateKeySigner(TEST_KEY);
        Signature sig = signer.signTypedData(domain, "Permit", types, message);

        // Verify signature matches expected (from viem/ethers)
        assertNotNull(sig);
        assertTrue(sig.v() == 27 || sig.v() == 28);
    }

    @Test
    void hashTypedData_recoversCorrectSigner() {
        // Sign, then recover address from signature
        // Verify recovered address matches signer
    }
}
```

### Test Vectors

Use official EIP-712 test vectors:
- [EIP-712 specification examples](https://eips.ethereum.org/EIPS/eip-712)
- [eth-sig-util test fixtures](https://github.com/MetaMask/eth-sig-util)
- Cross-reference with viem/ethers.js output

---

## Reference Implementations

### viem (TypeScript)

- **signTypedData**: https://viem.sh/docs/actions/wallet/signTypedData
- **hashTypedData**: https://viem.sh/docs/utilities/hashTypedData
- **Source**: https://github.com/wevm/viem/blob/main/src/utils/signature/hashTypedData.ts

Key patterns:
- Domain treated as struct with type "EIP712Domain"
- Type dependencies collected and sorted alphabetically
- Recursive encodeData for nested structs

### alloy (Rust)

- **SolStruct trait**: https://docs.rs/alloy-sol-types/latest/alloy_sol_types/trait.SolStruct.html
- **Eip712Domain**: https://docs.rs/alloy-sol-types/latest/alloy_sol_types/struct.Eip712Domain.html

Key patterns:
- `eip712_encode_type()` - canonical type string
- `eip712_type_hash()` - keccak256 of encode_type
- `eip712_hash_struct()` - typeHash || encodeData
- `eip712_signing_hash()` - full EIP-712 hash with domain

### Naming Convention Alignment

| Concept | viem | alloy | Brane |
|---------|------|-------|-------|
| Sign typed data | `signTypedData` | `sign_typed_data` | `signTypedData` |
| Hash typed data | `hashTypedData` | `eip712_signing_hash` | `hashTypedData` |
| Domain separator | `domain` | `Eip712Domain` | `Eip712Domain` |
| Type hash | internal | `eip712_type_hash` | `typeHash` |
| Struct hash | internal | `eip712_hash_struct` | `hashStruct` |

---

## Implementation Checklist

### Phase 1: Core Types & Parsing
- [ ] `Eip712Type` sealed interface with all type records
- [ ] `Eip712TypeParser.parse()` with full regex handling
- [ ] `Eip712TypeParser.toSolidityType()` for reverse conversion
- [ ] `Eip712Domain` record with builder
- [ ] `TypedDataField` record with validation
- [ ] `Eip712Exception` extending AbiEncodingException
- [ ] Unit tests for type parsing (all Solidity types)

### Phase 2: Encoding Engine
- [ ] `TypedDataEncoder.encodeType()` (three-phase algorithm)
- [ ] `TypedDataEncoder.collectDependencies()` with cycle detection
- [ ] `TypedDataEncoder.typeHash()`
- [ ] `TypedDataEncoder.encodeData()` (all primitives)
- [ ] `TypedDataEncoder.encodeField()` using parser
- [ ] `TypedDataEncoder.hashStruct()`
- [ ] `TypedDataEncoder.hashDomain()`
- [ ] Array encoding (`Type[]`, `Type[N]`)
- [ ] Nested struct encoding (recursive hashStruct)
- [ ] Unit tests with official EIP-712 test vectors

### Phase 3: Type-Safe API (PRIMARY)
- [ ] `TypedData<T>` container class
- [ ] `TypeDefinition<T>` record with forRecord() factory
- [ ] `TypedData.hash()` implementation
- [ ] `TypedData.sign()` implementation
- [ ] Integration with `Signer` interface

### Phase 4: Dynamic API (SECONDARY)
- [ ] `TypedDataSigner.signTypedData()` static method
- [ ] `TypedDataSigner.hashTypedData()` static method
- [ ] `Signer.signTypedData()` default method
- [ ] `PrivateKeySigner.signTypedData()` override (signFast + Keccak256 multi-arg)

### Phase 5: JSON Support
- [ ] `TypedDataJson.parse()` with Jackson
- [ ] `TypedDataPayload` record with validation
- [ ] `TypedData.fromPayload()` conversion
- [ ] `ValueCoercer` class for type coercion (String → BigInteger, etc.)
- [ ] Unit tests for JSON parsing and value coercion

### Phase 6: Integration & Examples
- [ ] Integration tests with Anvil
- [ ] Cross-validation with viem/ethers output
- [ ] `Eip712SigningExample.java` (type-safe)
- [ ] `Eip712PermitExample.java` (ERC-2612)
- [ ] `Eip712WalletConnectExample.java` (JSON)
- [ ] Javadoc for all public APIs
- [ ] Update CLAUDE.md with EIP-712 info

---

## Files to Create/Modify

### New Files
```
brane-core/src/main/java/io/brane/core/crypto/eip712/
├── Eip712Domain.java           # Domain separator record + builder
├── Eip712Type.java             # Sealed interface for type representation
├── Eip712TypeParser.java       # Solidity type string parsing
├── Eip712Exception.java        # Exception (extends BraneException)
├── TypedData.java              # Type-safe container (PRIMARY API)
├── TypeDefinition.java         # Type structure for Java types
├── TypedDataField.java         # Field definition record
├── TypedDataSigner.java        # Dynamic API (SECONDARY)
├── TypedDataEncoder.java       # Internal encoding logic
├── TypedDataJson.java          # JSON parsing support
├── TypedDataPayload.java       # Raw JSON payload record
└── ValueCoercer.java           # Internal value type coercion

brane-core/src/test/java/io/brane/core/crypto/eip712/
├── Eip712TypeParserTest.java   # Type parsing tests
├── TypedDataEncoderTest.java   # Encoding tests with EIP-712 vectors
├── TypedDataSignerTest.java    # Integration tests
├── TypedDataJsonTest.java      # JSON parsing tests
├── Eip712DomainTest.java       # Domain separator tests
└── ValueCoercerTest.java       # Value coercion tests

brane-examples/src/main/java/io/brane/examples/
├── Eip712SigningExample.java          # Basic type-safe signing
├── Eip712PermitExample.java           # ERC-2612 Permit example
└── Eip712WalletConnectExample.java    # JSON parsing from dapp
```

### Modified Files
```
brane-core/src/main/java/io/brane/core/error/BraneException.java
  - Add Eip712Exception to sealed permits list:
    permits AbiDecodingException, AbiEncodingException, Eip712Exception, RevertException, RpcException, TxnException

brane-core/src/main/java/io/brane/core/crypto/Signer.java
  - Add default signTypedData() method with Map-based API
  - Add overloaded signTypedData(TypedData<T>) for type-safe API

brane-core/src/main/java/io/brane/core/crypto/PrivateKeySigner.java
  - Override signTypedData() using signFast() and Keccak256 multi-arg
```
