# ERC-8004: Trustless Agents — Brane SDK Integration Spec

## Overview

[ERC-8004](https://eips.ethereum.org/EIPS/eip-8004) ("Trustless Agents") establishes three
lightweight on-chain registries that enable autonomous agents to discover, authenticate, and
collaborate across organizational boundaries without centralized intermediaries.

The standard defines:

| Registry | Purpose | ERC Dependency |
|----------|---------|----------------|
| **Identity** | Agent registration, URI storage, metadata, wallet binding | ERC-721 |
| **Reputation** | Feedback submission, scoring, revocation, responses | — |
| **Validation** | Third-party task verification with request/response flow | — |

Cross-cutting dependencies: EIP-155, EIP-712 (agent wallet signatures), EIP-1271 (smart contract wallets).

**Authors:** Marco De Rossi (MetaMask), Davide Crapis (Ethereum Foundation), Jordan Ellis (Google), Erik Reppel (Coinbase).

**Status:** Draft. Live on Ethereum mainnet (Jan 29 2026). Reference implementation deployed on Sepolia.

---

## ERC-8004 Contract Interfaces

### Identity Registry

```solidity
// Agent registration (ERC-721 token)
function register(string agentURI, MetadataEntry[] calldata metadata) external returns (uint256 agentId);
function register(string agentURI) external returns (uint256 agentId);
function register() external returns (uint256 agentId);

// URI management
function setAgentURI(uint256 agentId, string calldata newURI) external;

// Metadata (key-value pairs, arbitrary bytes)
function getMetadata(uint256 agentId, string memory metadataKey) external view returns (bytes memory);
function setMetadata(uint256 agentId, string memory metadataKey, bytes memory metadataValue) external;

// Agent wallet (payment address, requires EIP-712 signature or ERC-1271)
function setAgentWallet(uint256 agentId, address newWallet, uint256 deadline, bytes calldata signature) external;
function getAgentWallet(uint256 agentId) external view returns (address);
function unsetAgentWallet(uint256 agentId) external;

struct MetadataEntry {
    string metadataKey;
    bytes metadataValue;
}

event Registered(uint256 indexed agentId, string agentURI, address indexed owner);
event URIUpdated(uint256 indexed agentId, string newURI, address indexed updatedBy);
event MetadataSet(uint256 indexed agentId, string indexed indexedMetadataKey,
                  string metadataKey, bytes metadataValue);
```

### Reputation Registry

```solidity
function getIdentityRegistry() external view returns (address);

// Submit feedback (caller must not be agent owner/operator)
function giveFeedback(uint256 agentId, int128 value, uint8 valueDecimals,
    string calldata tag1, string calldata tag2, string calldata endpoint,
    string calldata feedbackURI, bytes32 feedbackHash) external;

// Revoke feedback (only original submitter)
function revokeFeedback(uint256 agentId, uint64 feedbackIndex) external;

// Append response to existing feedback (anyone)
function appendResponse(uint256 agentId, address clientAddress,
    uint64 feedbackIndex, string calldata responseURI, bytes32 responseHash) external;

// Read operations
function getSummary(uint256 agentId, address[] calldata clientAddresses,
    string tag1, string tag2) external view returns (uint64 count, int128 summaryValue, uint8 summaryValueDecimals);
function readFeedback(uint256 agentId, address clientAddress, uint64 feedbackIndex)
    external view returns (int128 value, uint8 valueDecimals, string tag1, string tag2, bool isRevoked);
function readAllFeedback(uint256 agentId, address[] calldata clientAddresses,
    string tag1, string tag2, bool includeRevoked) external view
    returns (address[] memory, uint64[] memory, int128[] memory, uint8[] memory,
             string[] memory, string[] memory, bool[] memory);
function getClients(uint256 agentId) external view returns (address[] memory);
function getLastIndex(uint256 agentId, address clientAddress) external view returns (uint64);
function getResponseCount(uint256 agentId, address clientAddress,
    uint64 feedbackIndex, address[] responders) external view returns (uint64);

event NewFeedback(uint256 indexed agentId, address indexed clientAddress,
    uint64 feedbackIndex, int128 value, uint8 valueDecimals,
    string indexed indexedTag1, string tag1, string tag2,
    string endpoint, string feedbackURI, bytes32 feedbackHash);
event FeedbackRevoked(uint256 indexed agentId, address indexed clientAddress,
    uint64 indexed feedbackIndex);
event ResponseAppended(uint256 indexed agentId, address indexed clientAddress,
    uint64 feedbackIndex, address indexed responder, string responseURI, bytes32 responseHash);
```

### Validation Registry

```solidity
function getIdentityRegistry() external view returns (address);

// Request validation (only agent owner/operator)
function validationRequest(address validatorAddress, uint256 agentId,
    string requestURI, bytes32 requestHash) external;

// Respond to validation (only designated validator)
function validationResponse(bytes32 requestHash, uint8 response,
    string responseURI, bytes32 responseHash, string tag) external;

// Read operations
function getValidationStatus(bytes32 requestHash) external view
    returns (address validatorAddress, uint256 agentId, uint8 response,
             bytes32 responseHash, string tag, uint256 lastUpdate);
function getSummary(uint256 agentId, address[] calldata validatorAddresses, string tag)
    external view returns (uint64 count, uint8 averageResponse);
function getAgentValidations(uint256 agentId) external view returns (bytes32[] memory);
function getValidatorRequests(address validatorAddress) external view returns (bytes32[] memory);

event ValidationRequest(address indexed validatorAddress, uint256 indexed agentId,
    string requestURI, bytes32 indexed requestHash);
event ValidationResponse(address indexed validatorAddress, uint256 indexed agentId,
    bytes32 indexed requestHash, uint8 response, string responseURI,
    bytes32 responseHash, string tag);
```

---

## Architecture — Where It Fits in Brane

```
brane-primitives (no deps)
       |
   brane-core
   ├── sh.brane.core.crypto.eip712     (existing — reused for agent wallet signatures)
   ├── sh.brane.core.crypto.erc8004    (NEW — EIP-712 wallet binding signatures)
   ├── sh.brane.core.types             (existing — Address, Hash, HexData)
   ├── sh.brane.core.erc8004           (NEW — domain types, event records, constants, identifiers)
   └── sh.brane.core.erc8004.registration (NEW — Agent Card JSON model)
       |
   brane-rpc
       |
   brane-contract
   └── sh.brane.contract.erc8004       (NEW — registry client)
```

ERC-8004 support spans two modules:

| Module | New Package | Responsibility |
|--------|-------------|----------------|
| `brane-core` | `sh.brane.core.erc8004` | Domain types (`AgentId`, `RegistryId`, `AgentIdentifier`, `FeedbackValue`, `MetadataEntry`), event records, deployed addresses |
| `brane-core` | `sh.brane.core.erc8004.registration` | Agent Card JSON model — parse the off-chain registration file pointed to by `tokenURI` |
| `brane-core` | `sh.brane.core.crypto.erc8004` | EIP-712 wallet binding signature (follows `eip3009` convention) |
| `brane-contract` | `sh.brane.contract.erc8004` | High-level registry client with raw `eth_call` + ABI decoding for tuple returns |

---

## Detailed Design

### 1. Core Types (`brane-core`)

#### `AgentId` — Agent Token Identifier

```java
// Wraps the uint256 ERC-721 token ID
public record AgentId(BigInteger value) {
    public AgentId {
        Objects.requireNonNull(value, "agentId");
        if (value.signum() < 0) throw new IllegalArgumentException("agentId must be non-negative");
    }

    public static AgentId of(long id) { return new AgentId(BigInteger.valueOf(id)); }
}
```

#### `FeedbackValue` — Fixed-Point Score

```java
// Signed fixed-point: value=9977, decimals=2 → 99.77%
// Signed fixed-point: value=-32, decimals=1  → -3.2%
// Uses BigInteger because Solidity int128 exceeds Java long range
public record FeedbackValue(BigInteger value, int decimals) {
    public FeedbackValue {
        Objects.requireNonNull(value, "value");
        if (decimals < 0 || decimals > 18) throw new IllegalArgumentException("decimals must be 0-18");
    }

    public BigDecimal toBigDecimal() {
        return new BigDecimal(value, decimals);
    }

    public static FeedbackValue of(long value, int decimals) {
        return new FeedbackValue(BigInteger.valueOf(value), decimals);
    }
}
```

#### `MetadataEntry` — Key-Value Pair

```java
public record MetadataEntry(String key, byte[] value) {
    public MetadataEntry {
        Objects.requireNonNull(key, "key");
        Objects.requireNonNull(value, "value");
        value = value.clone(); // defensive copy
    }

    public byte[] value() { return value.clone(); }
}
```

#### `RegistryId` — Multi-Chain Registry Identifier

ERC-8004 identifies registries across chains using the format `eip155:{chainId}:{address}`,
which is structurally identical to [CAIP-10](https://chainagnostic.org/CAIPs/caip-10)
(though the EIP doesn't formally reference CAIP). This format appears in the agent
registration file's `registrations[].agentRegistry` field and is standardized in the EIP text.

```java
/**
 * Identifies an ERC-8004 registry on a specific chain.
 *
 * <p>Format: {@code eip155:{chainId}:{address}} — structurally identical to CAIP-10.
 *
 * <p>Example: {@code eip155:1:0x8004a169fb4a3325136eb29fa0ceb6d2e539a432}
 *
 * @param chainId the EIP-155 chain ID (e.g., 1 for mainnet, 8453 for Base)
 * @param address the registry contract address on that chain
 */
public record RegistryId(long chainId, Address address) {

    private static final String NAMESPACE = "eip155";

    public RegistryId {
        if (chainId <= 0) throw new IllegalArgumentException("chainId must be positive");
        Objects.requireNonNull(address, "address");
    }

    /**
     * Parses a registry identifier string.
     *
     * @param id the identifier (e.g., "eip155:1:0x8004a169...")
     * @return the parsed RegistryId
     * @throws IllegalArgumentException if the format is invalid or namespace is not "eip155"
     */
    public static RegistryId parse(String id) {
        Objects.requireNonNull(id, "id");
        String[] parts = id.split(":");
        if (parts.length != 3) throw new IllegalArgumentException(
            "Expected format eip155:{chainId}:{address}, got: " + id);
        if (!NAMESPACE.equals(parts[0])) throw new IllegalArgumentException(
            "Unsupported namespace: " + parts[0]);
        long chainId = Long.parseLong(parts[1]);
        Address address = Address.from(parts[2]);
        return new RegistryId(chainId, address);
    }

    @Override
    public String toString() { return NAMESPACE + ":" + chainId + ":" + address.value(); }
}
```

#### `AgentIdentifier` — Full Agent Identity (Registry + Token ID)

Combines a `RegistryId` (which chain and which registry) with an `AgentId` (the ERC-721
token ID) to form a globally unique agent identifier.

```java
/**
 * Globally unique identifier for an ERC-8004 agent across all chains.
 *
 * <p>Combines the registry location ({@link RegistryId}) with the agent's
 * ERC-721 token ID ({@link AgentId}).
 *
 * @param registry identifies the chain and registry contract
 * @param agentId  the ERC-721 token ID within that registry
 */
public record AgentIdentifier(RegistryId registry, AgentId agentId) {

    public AgentIdentifier {
        Objects.requireNonNull(registry, "registry");
        Objects.requireNonNull(agentId, "agentId");
    }

    /** Shortcut: the chain ID from the registry. */
    public long chainId() { return registry.chainId(); }

    /** Shortcut: the registry contract address. */
    public Address registryAddress() { return registry.address(); }

    /**
     * Creates an identifier from individual components.
     *
     * @param chainId         the EIP-155 chain ID
     * @param registryAddress the registry contract address
     * @param agentId         the agent token ID
     * @return the agent identifier
     */
    public static AgentIdentifier of(long chainId, Address registryAddress, AgentId agentId) {
        return new AgentIdentifier(new RegistryId(chainId, registryAddress), agentId);
    }
}
```

#### Agent Registration File (`sh.brane.core.erc8004.registration`)

The Agent Card is an off-chain JSON document pointed to by the on-chain `tokenURI`.
The schema is defined in the [EIP text](https://eips.ethereum.org/EIPS/eip-8004) using
RFC-2119 language. Jackson is already a `brane-core` dependency, so no new dependency is
introduced.

```java
package sh.brane.core.erc8004.registration;

/**
 * ERC-8004 Agent Registration File (the "Agent Card").
 *
 * <p>Parsed from the JSON document at the agent's {@code tokenURI}. Enables
 * programmatic agent discovery — find an agent's service endpoints, supported
 * trust models, and cross-chain registrations.
 *
 * <p>Example:
 * <pre>{@code
 * AgentRegistration card = AgentRegistration.fromJson(jsonString);
 * card.services().stream()
 *     .filter(s -> "a2a".equals(s.name()))
 *     .findFirst()
 *     .ifPresent(s -> System.out.println("A2A endpoint: " + s.endpoint()));
 * }</pre>
 *
 * @param type           schema version URI (MUST be present)
 * @param name           human-readable agent name
 * @param description    natural language description of capabilities
 * @param image          avatar/logo URL
 * @param services       network endpoints the agent exposes
 * @param x402Support    whether the agent accepts x402 HTTP payments
 * @param active         whether the agent is currently operational
 * @param registrations  links to on-chain identity registrations
 * @param supportedTrust trust model categories
 *
 * @see <a href="https://eips.ethereum.org/EIPS/eip-8004">EIP-8004</a>
 */
@JsonIgnoreProperties(ignoreUnknown = true)
public record AgentRegistration(
    String type,
    @Nullable String name,
    @Nullable String description,
    @Nullable String image,
    @Nullable List<AgentService> services,
    @Nullable Boolean x402Support,
    @Nullable Boolean active,
    @Nullable List<ChainRegistration> registrations,
    @Nullable List<String> supportedTrust
) {
    private static final ObjectMapper MAPPER = new ObjectMapper()
        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);

    public static AgentRegistration fromJson(String json) {
        try {
            return MAPPER.readValue(json, AgentRegistration.class);
        } catch (JsonProcessingException e) {
            throw new IllegalArgumentException("Invalid agent registration JSON: " + e.getMessage(), e);
        }
    }
}

/**
 * A service endpoint exposed by an agent.
 *
 * @param name     service type: "a2a", "mcp", "web", "ens", etc. (MUST)
 * @param endpoint service URL or identifier (MUST)
 * @param version  protocol version
 * @param skills   capability tags (OASF taxonomy)
 * @param domains  domain categories
 */
@JsonIgnoreProperties(ignoreUnknown = true)
public record AgentService(
    String name,
    String endpoint,
    @Nullable String version,
    @Nullable List<String> skills,
    @Nullable List<String> domains
) {}

/**
 * Cross-chain registration entry linking an on-chain identity to this card.
 *
 * @param agentId       the ERC-721 token ID
 * @param agentRegistry the registry identifier in {@code eip155:{chainId}:{address}} format
 */
@JsonIgnoreProperties(ignoreUnknown = true)
public record ChainRegistration(
    BigInteger agentId,
    String agentRegistry
) {
    /** Parses the {@code agentRegistry} string into a typed {@link RegistryId}. */
    public RegistryId toRegistryId() { return RegistryId.parse(agentRegistry); }

    /** Constructs a full {@link AgentIdentifier} from this registration entry. */
    public AgentIdentifier toAgentIdentifier() {
        return new AgentIdentifier(toRegistryId(), new AgentId(agentId));
    }
}
```

#### Event Records

Event records MUST use raw ABI-decoded types in their constructors because
`Abi.decodeEvents()` instantiates them via reflection (`ctor.newInstance(values...)`)
with the raw decoded values (`BigInteger` for uint/int, `Address` for address, etc.).
Wrapper types like `AgentId` would cause `IllegalArgumentException` at decode time.

```java
// Decoded from on-chain logs — constructors use raw ABI types
public record AgentRegistered(BigInteger agentId, String agentURI, Address owner) {
    /** Convenience accessor. */
    public AgentId toAgentId() { return new AgentId(agentId); }
}

public record FeedbackSubmitted(
    BigInteger agentId, Address client, BigInteger feedbackIndex,
    BigInteger value, BigInteger valueDecimals, String tag1, String tag2,
    String endpoint, String feedbackURI, byte[] feedbackHash) {
    public AgentId toAgentId() { return new AgentId(agentId); }
    public FeedbackValue toFeedbackValue() { return new FeedbackValue(value, valueDecimals.intValue()); }
}

public record FeedbackRevoked(BigInteger agentId, Address client, BigInteger feedbackIndex) {}

public record ValidationRequested(
    Address validator, BigInteger agentId,
    String requestURI, byte[] requestHash) {}

public record ValidationResponded(
    Address validator, BigInteger agentId, byte[] requestHash,
    BigInteger response, String responseURI, byte[] responseHash, String tag) {}
```

#### `Erc8004Addresses` — Known Deployments

Mainnet contracts use deterministic CREATE2 deployment with `0x8004` vanity prefix.
**The same addresses are shared across all mainnet EVM chains** (Ethereum, Base, Arbitrum,
Polygon, Optimism, Avalanche, Celo, Gnosis, Linea, Mantle, Scroll, Taiko, etc.).

Source: [erc-8004/erc-8004-contracts](https://github.com/erc-8004/erc-8004-contracts)

```java
public final class Erc8004Addresses {

    // ─── Mainnet (all EVM chains — deterministic CREATE2 deployment) ───
    public static final Address MAINNET_IDENTITY   = Address.from("0x8004a169fb4a3325136eb29fa0ceb6d2e539a432");
    public static final Address MAINNET_REPUTATION = Address.from("0x8004baa17c55a88189ae136b182e5fda19de9b63");
    // ValidationRegistry: not yet publicly documented — omitted until official source confirms

    // ─── Testnets (Sepolia, Base Sepolia, Arbitrum Sepolia — shared addresses) ───
    public static final Address SEPOLIA_IDENTITY   = Address.from("0x8004a818bfb912233c491871b3d84c89a494bd9e");
    public static final Address SEPOLIA_REPUTATION = Address.from("0x8004b663056a597dffe9eccc1965a193b7388713");
    // ValidationRegistry: not yet publicly documented for official deployment

    // ─── Reference Implementation (ChaosChain — Sepolia only) ───
    // These are the addresses from the ChaosChain reference implementation, distinct
    // from the official erc-8004-contracts deployment above.
    public static final Address RI_SEPOLIA_IDENTITY   = Address.from("0xf66e7cbdae1cb710fee7732e4e1f173624e137a7");
    public static final Address RI_SEPOLIA_REPUTATION = Address.from("0x6e2a285294b5c74cb76d76ab77c1ef15c2a9e407");
    public static final Address RI_SEPOLIA_VALIDATION = Address.from("0xc26171a3c4e1d958cea196a5e84b7418c58dca2c");

    private Erc8004Addresses() {}
}
```

#### EIP-712 Agent Wallet Signature (`sh.brane.core.crypto.erc8004`)

The Identity Registry's `setAgentWallet()` requires an EIP-712 signature proving wallet ownership.
This follows the same pattern as `Eip3009` in `sh.brane.core.crypto.eip3009`:

```java
// Package: sh.brane.core.crypto.erc8004
public final class Erc8004Wallet {

    // EIP-712 type for agent wallet binding
    public record AgentWalletBinding(BigInteger agentId, Address wallet, BigInteger deadline) {
        public static final TypeDefinition<AgentWalletBinding> DEFINITION =
            TypeDefinition.forRecord(
                AgentWalletBinding.class,
                "AgentWalletBinding",
                Map.of("AgentWalletBinding", List.of(
                    TypedDataField.of("agentId", "uint256"),
                    TypedDataField.of("wallet", "address"),
                    TypedDataField.of("deadline", "uint256")
                ))
            );
    }

    public static Signature signWalletBinding(
            AgentWalletBinding binding, Eip712Domain domain, Signer signer) {
        return TypedData.create(domain, AgentWalletBinding.DEFINITION, binding).sign(signer);
    }
}
```

### 2. Registry Clients (`brane-contract`)

#### Java Interfaces for Contract Binding

These interfaces are bound via `BraneContract.bind()` — matching the existing no-codegen pattern.

**Constraint:** `BraneContract.bind()` only allows `TransactionReceipt`, `void`, or `Void`
as return types for non-view (state-changing) functions. The Solidity `register()` returns
`uint256 agentId`, but since it's state-changing, the Java binding must return
`TransactionReceipt`. The `agentId` is extracted from the `Registered` event in the receipt.

**Constraint:** `BraneContract.bind()` does not support tuple/struct return types for view
functions. Methods like `getSummary()`, `readFeedback()`, and `getValidationStatus()` return
multi-value tuples. These cannot be bound via the proxy — they require raw `eth_call` +
manual `AbiDecoder` decoding. Only single-return-value view functions can use the proxy.

```java
// Internal interface — bound to the Identity Registry contract
// Only single-return view functions and write functions are proxy-bindable
interface IdentityRegistryContract {
    // Write functions → TransactionReceipt (agentId extracted from Registered event)
    TransactionReceipt register(String agentURI);
    TransactionReceipt setAgentURI(BigInteger agentId, String newURI);
    TransactionReceipt setMetadata(BigInteger agentId, String metadataKey, byte[] metadataValue);
    TransactionReceipt setAgentWallet(BigInteger agentId, Address newWallet, BigInteger deadline, byte[] signature);
    TransactionReceipt unsetAgentWallet(BigInteger agentId);

    // Single-return view functions → proxy-bindable
    byte[] getMetadata(BigInteger agentId, String metadataKey);
    Address getAgentWallet(BigInteger agentId);
}

// Internal interface — bound to the Reputation Registry contract
interface ReputationRegistryContract {
    // Single-return view functions → proxy-bindable
    Address getIdentityRegistry();

    // Write functions
    TransactionReceipt giveFeedback(BigInteger agentId, BigInteger value, BigInteger valueDecimals,
        String tag1, String tag2, String endpoint, String feedbackURI, byte[] feedbackHash);
    TransactionReceipt revokeFeedback(BigInteger agentId, BigInteger feedbackIndex);
    TransactionReceipt appendResponse(BigInteger agentId, Address clientAddress,
        BigInteger feedbackIndex, String responseURI, byte[] responseHash);

    // NOTE: getSummary(), readFeedback(), readAllFeedback() return tuples
    // and cannot be proxy-bound. Use raw eth_call + AbiDecoder instead.
}

// Internal interface — bound to the Validation Registry contract
interface ValidationRegistryContract {
    // Single-return view functions → proxy-bindable
    Address getIdentityRegistry();

    // Write functions
    TransactionReceipt validationRequest(Address validatorAddress, BigInteger agentId,
        String requestURI, byte[] requestHash);
    TransactionReceipt validationResponse(byte[] requestHash, BigInteger response,
        String responseURI, byte[] responseHash, String tag);

    // NOTE: getValidationStatus(), getSummary() return tuples
    // and cannot be proxy-bound. Use raw eth_call + AbiDecoder instead.
}
```

#### Tuple Return Decoding (Raw `eth_call`)

For view functions that return multiple values, `TrustlessAgents` bypasses the proxy
and uses raw `eth_call` + `AbiDecoder` directly:

```java
// Example: getSummary(uint256,address[],string,string) → (uint64, int128, uint8)
public FeedbackSummary getSummary(AgentId agentId, List<Address> clients, String tag1, String tag2) {
    HexData calldata = reputationAbi.encodeFunction("getSummary",
        agentId.value(), clients.toArray(Address[]::new), tag1, tag2);
    HexData result = client.call(CallRequest.builder()
        .to(reputationAddress)
        .data(calldata)
        .build());

    // Manual tuple decoding — 3 return values
    List<AbiType> decoded = AbiDecoder.decode(Hex.decode(result.value()),
        List.of(uint64Schema, int128Schema, uint8Schema));
    long count = ((UInt) decoded.get(0)).value().longValue();
    BigInteger summaryValue = ((Int) decoded.get(1)).value();
    int decimals = ((UInt) decoded.get(2)).value().intValue();
    return new FeedbackSummary(count, new FeedbackValue(summaryValue, decimals));
}
```

#### High-Level Client: `TrustlessAgents`

Wraps the three registries behind a single ergonomic API:

```java
public final class TrustlessAgents {

    // Factory — explicit addresses
    public static TrustlessAgents connect(Brane.Signer client,
        Address identity, Address reputation);

    // Convenience for mainnet (all EVM chains share the same addresses)
    // Uses MAINNET_IDENTITY and MAINNET_REPUTATION from Erc8004Addresses
    public static TrustlessAgents connectMainnet(Brane.Signer client);

    // Convenience for Sepolia testnet
    public static TrustlessAgents connectSepolia(Brane.Signer client);

    // Read-only variant (tuple reads via raw eth_call, no proxy needed for writes)
    public static TrustlessAgents.ReadOnly connectReadOnly(Brane client,
        Address identity, Address reputation);
    public static TrustlessAgents.ReadOnly connectMainnetReadOnly(Brane client);

    // ─── Identity ──────────────────────────────────────────────
    // register() extracts agentId from the Registered event in the receipt
    public AgentId register(String agentURI);
    public AgentId register(String agentURI, List<MetadataEntry> metadata);
    public void setAgentURI(AgentId agentId, String newURI);
    public void setMetadata(AgentId agentId, String key, byte[] value);
    public byte[] getMetadata(AgentId agentId, String key);
    public void bindWallet(AgentId agentId, Address wallet, Signer walletSigner);
    public Address getAgentWallet(AgentId agentId);

    // ─── Reputation ───────────────────────────────────────────
    public void giveFeedback(AgentId agentId, FeedbackValue score,
        String tag1, String tag2);
    public void giveFeedback(AgentId agentId, FeedbackValue score,
        String tag1, String tag2, String endpoint,
        String feedbackURI, Hash feedbackHash);
    public void revokeFeedback(AgentId agentId, long feedbackIndex);
    public void appendResponse(AgentId agentId, Address client,
        long feedbackIndex, String responseURI, Hash responseHash);
    public FeedbackSummary getSummary(AgentId agentId);
    public FeedbackSummary getSummary(AgentId agentId,
        List<Address> clients, String tag1, String tag2);
    public List<FeedbackSubmitted> getAllFeedback(AgentId agentId);

    // ─── Validation ───────────────────────────────────────────
    public Hash requestValidation(Address validator, AgentId agentId,
        String requestURI, byte[] requestPayload);
    public void respondToValidation(Hash requestHash, int response,
        String responseURI, byte[] responsePayload, String tag);
    public ValidationStatus getValidationStatus(Hash requestHash);
    public ValidationSummary getValidationSummary(AgentId agentId);

    // ─── Events ───────────────────────────────────────────────
    public List<AgentRegistered> getRegistrations(long fromBlock, long toBlock);
    public List<FeedbackSubmitted> getFeedbackEvents(AgentId agentId,
        long fromBlock, long toBlock);
    public List<ValidationResponded> getValidationEvents(AgentId agentId,
        long fromBlock, long toBlock);

    // ─── Agent Discovery ─────────────────────────────────────
    // Reads tokenURI from the Identity Registry, then parses the JSON Agent Card.
    // The HTTP fetch is left to the caller — Brane provides the parsing.
    public String getAgentURI(AgentId agentId);  // raw tokenURI string

    // Parse a fetched registration file
    // (static — does not require a connected client)
    public static AgentRegistration parseRegistration(String json);
}
```

#### Summary Records

These are high-level domain types returned by `TrustlessAgents`, constructed from
raw tuple decoding — NOT decoded via `Abi.decodeEvents()`, so they can use wrapper types.

```java
public record FeedbackSummary(long count, FeedbackValue aggregateScore) {}

public record ValidationStatus(
    Address validator, AgentId agentId, int response,
    Hash responseHash, String tag, long lastUpdate) {}

public record ValidationSummary(long count, int averageResponse) {}
```

---

## Integration with Existing Brane Patterns

### Pattern 1: EIP-712 Typed Data (agent wallet binding)

Follows the `Eip3009` pattern exactly:

```
EIP-3009                           ERC-8004
─────────                          ─────────
TransferAuthorization (record)     AgentWalletBinding (record)
  └─ DEFINITION (TypeDefinition)     └─ DEFINITION (TypeDefinition)
Eip3009.sign(auth, domain, signer) Erc8004Wallet.signWalletBinding(binding, domain, signer)
Eip3009.usdcDomain(chainId, addr)  (domain built from registry address)
```

### Pattern 2: Contract Binding (no codegen)

Follows the existing `BraneContract.bind()` pattern. Write functions return
`TransactionReceipt`; return values are extracted from events in the receipt.

```java
// How it works internally
var identityAbi = Abi.fromJson(IDENTITY_REGISTRY_ABI);
var contract = BraneContract.bind(
    registryAddress, IDENTITY_REGISTRY_ABI, signerClient,
    IdentityRegistryContract.class);

// Write function returns TransactionReceipt — extract agentId from event
TransactionReceipt receipt = contract.register(agentURI);
List<AgentRegistered> events = identityAbi.decodeEvents("Registered", receipt.logs(), AgentRegistered.class);
AgentId id = events.getFirst().toAgentId();
```

### Pattern 3: Event Decoding

`LogFilter` is a record with factory methods (`byContract`, `byContracts`) — it does not
have a builder. For block-range queries, construct the record directly with `Optional` fields.

```java
// Decode on-chain events using existing ABI event decoding
Hash registeredTopic = Abi.eventTopic("Registered(uint256,string,address)");
LogFilter filter = new LogFilter(
    Optional.of(fromBlock),
    Optional.of(toBlock),
    Optional.of(List.of(identityRegistryAddress)),
    Optional.of(List.of(registeredTopic)));

List<LogEntry> logs = client.getLogs(filter);
List<AgentRegistered> events = abi.decodeEvents("Registered", logs, AgentRegistered.class);
```

### Pattern 4: Error Handling

No new exception subclass needed. ERC-8004 operations map to existing exceptions:

| Failure | Exception |
|---------|-----------|
| Contract revert (e.g., not agent owner) | `RevertException` |
| RPC communication failure | `RpcException` |
| ABI encoding/decoding issue | `AbiEncodingException` / `AbiDecodingException` |
| EIP-712 signature failure | `Eip712Exception` |

---

## Example Usage

### Connect to Mainnet

```java
// All mainnet EVM chains share the same registry addresses (CREATE2 deployment)
var agents = TrustlessAgents.connectMainnet(signerClient);

// Or explicit addresses for custom/private deployments
var custom = TrustlessAgents.connect(signerClient, identityAddr, reputationAddr);

// Read-only (no signer needed)
var reader = TrustlessAgents.connectMainnetReadOnly(readerClient);
```

### Register an Agent

```java
var agents = TrustlessAgents.connectSepolia(signerClient);

// Register with URI pointing to agent registration file
// Internally: sends tx, decodes Registered event from receipt, returns AgentId
AgentId myAgent = agents.register("https://myagent.example.com/.well-known/agent-registration.json");

// Set metadata
agents.setMetadata(myAgent, "version", "1.0".getBytes());

// Bind a payment wallet (EIP-712 signed)
agents.bindWallet(myAgent, paymentAddress, paymentWalletSigner);
```

### Give Feedback

```java
// Rate an agent's performance (87/100 on "quality")
agents.giveFeedback(
    agentId,
    FeedbackValue.of(87, 0),  // 87 with 0 decimals → BigInteger.valueOf(87)
    "quality", "api-call"
);

// Query reputation summary (uses raw eth_call + tuple decoding internally)
FeedbackSummary summary = agents.getSummary(agentId);
System.out.println("Score: " + summary.aggregateScore().toBigDecimal());
```

### Request Validation

```java
// Request a third-party to validate agent work
byte[] requestPayload = /* ... task description ... */;
Hash requestHash = agents.requestValidation(
    validatorAddress, myAgent,
    "ipfs://QmTaskDescription...", requestPayload);

// Validator responds (from validator's client)
agents.respondToValidation(requestHash, 95,
    "ipfs://QmValidationReport...", reportPayload, "accuracy");

// Check status
ValidationStatus status = agents.getValidationStatus(requestHash);
```

### Query Historical Events

```java
// Get all registrations in a block range
List<AgentRegistered> registrations = agents.getRegistrations(
    18_000_000L, 18_100_000L);

// Get feedback for a specific agent
List<FeedbackSubmitted> feedback = agents.getFeedbackEvents(
    agentId, 18_000_000L, 18_100_000L);
```

### Agent Discovery (Registration File)

```java
// Get the agent's registration URI from on-chain
String uri = agents.getAgentURI(agentId);

// Fetch the JSON yourself (Brane doesn't include an HTTP client)
String json = myHttpClient.get(uri);

// Parse the Agent Card
AgentRegistration card = AgentRegistration.fromJson(json);

// Discover services
card.services().stream()
    .filter(s -> "a2a".equals(s.name()))
    .findFirst()
    .ifPresent(s -> System.out.println("A2A endpoint: " + s.endpoint()));

// Check x402 payment support
if (Boolean.TRUE.equals(card.x402Support())) {
    System.out.println("Agent accepts x402 payments");
}

// Resolve cross-chain registrations
for (ChainRegistration reg : card.registrations()) {
    AgentIdentifier id = reg.toAgentIdentifier();
    System.out.println("Chain " + id.chainId() + " agent #" + id.agentId().value());
}
```

### Multi-Chain Agent Identifiers

```java
// Parse a registry identifier from a registration file or external source
RegistryId mainnetRegistry = RegistryId.parse("eip155:1:0x8004a169fb4a3325136eb29fa0ceb6d2e539a432");
System.out.println(mainnetRegistry.chainId());  // 1
System.out.println(mainnetRegistry.address());   // 0x8004a169...

// Build a full agent identifier
var agentId = AgentId.of(42);
var identifier = new AgentIdentifier(mainnetRegistry, agentId);

// Or from individual components
var identifier2 = AgentIdentifier.of(8453L, Erc8004Addresses.MAINNET_IDENTITY, AgentId.of(7));

// Serialize back to string
System.out.println(identifier.registry().toString());  // "eip155:1:0x8004a169..."
```

---

## Implementation Plan

### Phase 1: Core Types (`brane-core`)

1. Create `sh.brane.core.erc8004` package — domain types and event records
2. Create `sh.brane.core.crypto.erc8004` package — EIP-712 wallet binding (follows `eip3009` convention)
3. Add `AgentId`, `FeedbackValue` (BigInteger-based), `MetadataEntry` records
4. Add `RegistryId` (parses `eip155:{chainId}:{address}`) and `AgentIdentifier` (registry + agent ID)
5. Add event records using raw ABI types: `AgentRegistered`, `FeedbackSubmitted`,
   `FeedbackRevoked`, `ValidationRequested`, `ValidationResponded`
6. Add `Erc8004Addresses` with mainnet (shared CREATE2) and Sepolia deployments
7. Add `Erc8004Wallet` with EIP-712 wallet binding signature support
8. Unit tests for all types, identifier parsing, and EIP-712 signing

### Phase 2: Registration File Model (`brane-core`)

1. Create `sh.brane.core.erc8004.registration` package
2. Add `AgentRegistration`, `AgentService`, `ChainRegistration` records
3. Implement `AgentRegistration.fromJson(String)` using existing Jackson `ObjectMapper` pattern
4. `ChainRegistration.toRegistryId()` and `.toAgentIdentifier()` bridge to core identifier types
5. Unit tests: parse sample JSON, validate field mapping, handle unknown properties gracefully

### Phase 3: Contract Bindings (`brane-contract`)

1. Add ABI JSON files for the three registries (from reference implementation)
2. Create proxy-bindable interfaces (write functions → `TransactionReceipt`,
   single-return view functions only)
3. Implement raw `eth_call` + `AbiDecoder` for tuple-returning view functions
   (`getSummary`, `readFeedback`, `getValidationStatus`, etc.)
4. Build `TrustlessAgents` client with `connect()`, `connectMainnet()`, and `connectSepolia()` factories
5. Add `FeedbackSummary`, `ValidationStatus`, `ValidationSummary` records
6. Add `getAgentURI()` and `parseRegistration()` methods
7. Unit tests with mocked contract calls and mocked `eth_call` responses

### Phase 4: Integration Testing

1. Deploy reference contracts to local Anvil
2. End-to-end test: register → set metadata → bind wallet → give feedback → validate
3. Agent discovery test: register → getAgentURI → parseRegistration → resolve identifiers
4. Event querying tests across block ranges
5. Add to `brane-examples` with annotated examples

### Phase 5: Documentation

1. Javadoc on all public API
2. Add ERC-8004 section to `AGENTS.md`
3. Add examples to website docs

---

## Resolved Decisions

### 1. Mainnet Addresses — **Hardcoded** (resolved 2026-02-19)

ERC-8004 went live January 29, 2026. Contracts use deterministic CREATE2 deployment with
`0x8004` vanity prefix. **The same addresses are shared across all mainnet EVM chains**
(Ethereum, Base, Arbitrum, Polygon, Optimism, and 10+ others).

| Registry | Mainnet Address (all chains) | Source |
|----------|------------------------------|--------|
| IdentityRegistry | `0x8004a169fb4a3325136eb29fa0ceb6d2e539a432` | [erc-8004-contracts](https://github.com/erc-8004/erc-8004-contracts) |
| ReputationRegistry | `0x8004baa17c55a88189ae136b182e5fda19de9b63` | [erc-8004-contracts](https://github.com/erc-8004/erc-8004-contracts) |
| ValidationRegistry | Not yet publicly documented | — |

Testnets (Sepolia, Base Sepolia, etc.) share a different set: `0x8004a818...` (identity),
`0x8004b663...` (reputation). The previous Sepolia addresses (`0xf66e...`, `0x6e2a...`,
`0xc261...`) are from the ChaosChain reference implementation — kept as `RI_SEPOLIA_*`
constants for backward compatibility.

`connectMainnet()` and `connectSepolia()` factories are now provided. The `connect()` factory
accepts explicit addresses for private/custom deployments.

### 2. Registration File Parsing — **Yes, include it** (resolved 2026-02-19)

Brane will include a JSON model for the Agent Card (the off-chain registration file pointed to
by `tokenURI`). Rationale:

- Jackson is already a `brane-core` dependency — **no new dependency**
- The model is small (~3 records: `AgentRegistration`, `AgentService`, `ChainRegistration`)
- Programmatic agent discovery is the primary use case for reading `tokenURI`
- Other SDKs (agent0-ts, erc-8004-js, erc-8004-py) all include registration parsing
- `ChainRegistration.toAgentIdentifier()` bridges directly to the multi-chain identifier types

The model lives in `sh.brane.core.erc8004.registration`. Brane does **not** include an HTTP
client for fetching the URI — the caller fetches the JSON and passes it to
`AgentRegistration.fromJson(String)`.

### 3. WebSocket Subscriptions — **Deferred** (unchanged)

Not addressed in this round. Depends on `Brane.canSubscribe()` and WebSocket infrastructure
maturity. Remains an open item for future work.

### 4. Multi-Chain Agent Identifiers — **Dedicated types** (resolved 2026-02-19)

Brane models multi-chain identifiers as two dedicated types:

| Type | Purpose | Format |
|------|---------|--------|
| `RegistryId` | Identifies a registry on a specific chain | `eip155:{chainId}:{address}` |
| `AgentIdentifier` | Full agent identity (registry + token ID) | `RegistryId` + `AgentId` |

Rationale:

- The `eip155:{chainId}:{address}` format is **standardized in the EIP text itself** (not just
  a convention). It's structurally identical to [CAIP-10](https://chainagnostic.org/CAIPs/caip-10)
  though the EIP doesn't formally reference CAIP.
- Multi-chain is the reality — 15+ chains share the same contracts.
- Parsing/validation logic is non-trivial (namespace check, chain ID validation, address format).
- The format appears in the registration file schema (`registrations[].agentRegistry`).
- Type safety prevents mixing up raw strings — consistent with Brane's philosophy of wrapping
  primitives (`Address`, `AgentId`, `Hash`, `Wei`).
- Two types because the EIP uses the identifier at two levels: the registry level (in the
  registration file) and the agent level (registry + token ID).

---

## References

- [EIP-8004: Trustless Agents](https://eips.ethereum.org/EIPS/eip-8004)
- [Official Contract Deployments](https://github.com/erc-8004/erc-8004-contracts)
- [Ethereum Magicians Discussion](https://ethereum-magicians.org/t/erc-8004-trustless-agents/25098)
- [Reference Implementation (ChaosChain)](https://github.com/ChaosChain/trustless-agents-erc-ri)
- [Awesome ERC-8004 Resources](https://github.com/sudeepb02/awesome-erc8004)
- [Composable Security Explainer](https://composable-security.com/blog/erc-8004-a-practical-explainer-for-trustless-agents/)
- [Mantle ERC-8004 Deployment](https://www.prnewswire.com/news-releases/mantle-unlocks-autonomous-economy-with-erc-8004-deployment-302688549.html)
- [CAIP-10: Account ID Specification](https://chainagnostic.org/CAIPs/caip-10)
- [CAIP-2: Blockchain ID Specification](https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-2.md)
- [agent0-ts (TypeScript ERC-8004 SDK)](https://github.com/agent0lab/agent0-ts)
- [erc-8004-js (JavaScript ERC-8004 SDK)](https://github.com/tetratorus/erc-8004-js)
- [ERC-8004 Best Practices](https://best-practices.8004scan.io/docs/README.html)
