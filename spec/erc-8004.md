# ERC-8004: Trustless Agents — Brane SDK Integration Spec

## Overview

[ERC-8004](https://eips.ethereum.org/EIPS/eip-8004) ("Trustless Agents") establishes three
lightweight on-chain registries that enable autonomous agents to discover, authenticate, and
collaborate across organizational boundaries without centralized intermediaries.

The standard defines:

| Registry | Purpose | ERC Dependency |
|----------|---------|----------------|
| **Identity** | Agent registration, URI storage, metadata, wallet binding | ERC-721 |
| **Reputation** | Feedback submission, scoring, revocation, responses | — |
| **Validation** | Third-party task verification with request/response flow | — |

Cross-cutting dependencies: EIP-155, EIP-712 (agent wallet signatures), EIP-1271 (smart contract wallets).

**Authors:** Marco De Rossi (MetaMask), Davide Crapis (Ethereum Foundation), Jordan Ellis (Google), Erik Reppel (Coinbase).

**Status:** Draft. Live on Ethereum mainnet (Jan 29 2026). Reference implementation deployed on Sepolia.

---

## ERC-8004 Contract Interfaces

### Identity Registry

```solidity
// Agent registration (ERC-721 token)
function register(string agentURI, MetadataEntry[] calldata metadata) external returns (uint256 agentId);
function register(string agentURI) external returns (uint256 agentId);
function register() external returns (uint256 agentId);

// URI management
function setAgentURI(uint256 agentId, string calldata newURI) external;

// Metadata (key-value pairs, arbitrary bytes)
function getMetadata(uint256 agentId, string memory metadataKey) external view returns (bytes memory);
function setMetadata(uint256 agentId, string memory metadataKey, bytes memory metadataValue) external;

// Agent wallet (payment address, requires EIP-712 signature or ERC-1271)
function setAgentWallet(uint256 agentId, address newWallet, uint256 deadline, bytes calldata signature) external;
function getAgentWallet(uint256 agentId) external view returns (address);
function unsetAgentWallet(uint256 agentId) external;

struct MetadataEntry {
    string metadataKey;
    bytes metadataValue;
}

event Registered(uint256 indexed agentId, string agentURI, address indexed owner);
event URIUpdated(uint256 indexed agentId, string newURI, address indexed updatedBy);
event MetadataSet(uint256 indexed agentId, string indexed indexedMetadataKey,
                  string metadataKey, bytes metadataValue);
```

### Reputation Registry

```solidity
function getIdentityRegistry() external view returns (address);

// Submit feedback (caller must not be agent owner/operator)
function giveFeedback(uint256 agentId, int128 value, uint8 valueDecimals,
    string calldata tag1, string calldata tag2, string calldata endpoint,
    string calldata feedbackURI, bytes32 feedbackHash) external;

// Revoke feedback (only original submitter)
function revokeFeedback(uint256 agentId, uint64 feedbackIndex) external;

// Append response to existing feedback (anyone)
function appendResponse(uint256 agentId, address clientAddress,
    uint64 feedbackIndex, string calldata responseURI, bytes32 responseHash) external;

// Read operations
function getSummary(uint256 agentId, address[] calldata clientAddresses,
    string tag1, string tag2) external view returns (uint64 count, int128 summaryValue, uint8 summaryValueDecimals);
function readFeedback(uint256 agentId, address clientAddress, uint64 feedbackIndex)
    external view returns (int128 value, uint8 valueDecimals, string tag1, string tag2, bool isRevoked);
function readAllFeedback(uint256 agentId, address[] calldata clientAddresses,
    string tag1, string tag2, bool includeRevoked) external view
    returns (address[] memory, uint64[] memory, int128[] memory, uint8[] memory,
             string[] memory, string[] memory, bool[] memory);
function getClients(uint256 agentId) external view returns (address[] memory);
function getLastIndex(uint256 agentId, address clientAddress) external view returns (uint64);
function getResponseCount(uint256 agentId, address clientAddress,
    uint64 feedbackIndex, address[] responders) external view returns (uint64);

event NewFeedback(uint256 indexed agentId, address indexed clientAddress,
    uint64 feedbackIndex, int128 value, uint8 valueDecimals,
    string indexed indexedTag1, string tag1, string tag2,
    string endpoint, string feedbackURI, bytes32 feedbackHash);
event FeedbackRevoked(uint256 indexed agentId, address indexed clientAddress,
    uint64 indexed feedbackIndex);
event ResponseAppended(uint256 indexed agentId, address indexed clientAddress,
    uint64 feedbackIndex, address indexed responder, string responseURI, bytes32 responseHash);
```

### Validation Registry

```solidity
function getIdentityRegistry() external view returns (address);

// Request validation (only agent owner/operator)
function validationRequest(address validatorAddress, uint256 agentId,
    string requestURI, bytes32 requestHash) external;

// Respond to validation (only designated validator)
function validationResponse(bytes32 requestHash, uint8 response,
    string responseURI, bytes32 responseHash, string tag) external;

// Read operations
function getValidationStatus(bytes32 requestHash) external view
    returns (address validatorAddress, uint256 agentId, uint8 response,
             bytes32 responseHash, string tag, uint256 lastUpdate);
function getSummary(uint256 agentId, address[] calldata validatorAddresses, string tag)
    external view returns (uint64 count, uint8 averageResponse);
function getAgentValidations(uint256 agentId) external view returns (bytes32[] memory);
function getValidatorRequests(address validatorAddress) external view returns (bytes32[] memory);

event ValidationRequest(address indexed validatorAddress, uint256 indexed agentId,
    string requestURI, bytes32 indexed requestHash);
event ValidationResponse(address indexed validatorAddress, uint256 indexed agentId,
    bytes32 indexed requestHash, uint8 response, string responseURI,
    bytes32 responseHash, string tag);
```

---

## Architecture — Where It Fits in Brane

```
brane-primitives (no deps)
       |
   brane-core
   ├── sh.brane.core.crypto.eip712     (existing — reused for agent wallet signatures)
   ├── sh.brane.core.crypto.erc8004    (NEW — EIP-712 wallet binding signatures)
   ├── sh.brane.core.types             (existing — Address, Hash, HexData)
   └── sh.brane.core.erc8004           (NEW — domain types, event records, constants)
       |
   brane-rpc
       |
   brane-contract
   └── sh.brane.contract.erc8004       (NEW — registry client)
```

ERC-8004 support spans two modules:

| Module | New Package | Responsibility |
|--------|-------------|----------------|
| `brane-core` | `sh.brane.core.erc8004` | Domain types (`AgentId`, `FeedbackValue`, `MetadataEntry`), event records, deployed addresses |
| `brane-core` | `sh.brane.core.crypto.erc8004` | EIP-712 wallet binding signature (follows `eip3009` convention) |
| `brane-contract` | `sh.brane.contract.erc8004` | High-level registry client with raw `eth_call` + ABI decoding for tuple returns |

---

## Detailed Design

### 1. Core Types (`brane-core`)

#### `AgentId` — Agent Token Identifier

```java
// Wraps the uint256 ERC-721 token ID
public record AgentId(BigInteger value) {
    public AgentId {
        Objects.requireNonNull(value, "agentId");
        if (value.signum() < 0) throw new IllegalArgumentException("agentId must be non-negative");
    }

    public static AgentId of(long id) { return new AgentId(BigInteger.valueOf(id)); }
}
```

#### `FeedbackValue` — Fixed-Point Score

```java
// Signed fixed-point: value=9977, decimals=2 → 99.77%
// Signed fixed-point: value=-32, decimals=1  → -3.2%
// Uses BigInteger because Solidity int128 exceeds Java long range
public record FeedbackValue(BigInteger value, int decimals) {
    public FeedbackValue {
        Objects.requireNonNull(value, "value");
        if (decimals < 0 || decimals > 18) throw new IllegalArgumentException("decimals must be 0-18");
    }

    public BigDecimal toBigDecimal() {
        return new BigDecimal(value, decimals);
    }

    public static FeedbackValue of(long value, int decimals) {
        return new FeedbackValue(BigInteger.valueOf(value), decimals);
    }
}
```

#### `MetadataEntry` — Key-Value Pair

```java
public record MetadataEntry(String key, byte[] value) {
    public MetadataEntry {
        Objects.requireNonNull(key, "key");
        Objects.requireNonNull(value, "value");
        value = value.clone(); // defensive copy
    }

    public byte[] value() { return value.clone(); }
}
```

#### Event Records

Event records MUST use raw ABI-decoded types in their constructors because
`Abi.decodeEvents()` instantiates them via reflection (`ctor.newInstance(values...)`)
with the raw decoded values (`BigInteger` for uint/int, `Address` for address, etc.).
Wrapper types like `AgentId` would cause `IllegalArgumentException` at decode time.

```java
// Decoded from on-chain logs — constructors use raw ABI types
public record AgentRegistered(BigInteger agentId, String agentURI, Address owner) {
    /** Convenience accessor. */
    public AgentId toAgentId() { return new AgentId(agentId); }
}

public record FeedbackSubmitted(
    BigInteger agentId, Address client, BigInteger feedbackIndex,
    BigInteger value, BigInteger valueDecimals, String tag1, String tag2,
    String endpoint, String feedbackURI, byte[] feedbackHash) {
    public AgentId toAgentId() { return new AgentId(agentId); }
    public FeedbackValue toFeedbackValue() { return new FeedbackValue(value, valueDecimals.intValue()); }
}

public record FeedbackRevoked(BigInteger agentId, Address client, BigInteger feedbackIndex) {}

public record ValidationRequested(
    Address validator, BigInteger agentId,
    String requestURI, byte[] requestHash) {}

public record ValidationResponded(
    Address validator, BigInteger agentId, byte[] requestHash,
    BigInteger response, String responseURI, byte[] responseHash, String tag) {}
```

#### `Erc8004Addresses` — Known Deployments

```java
public final class Erc8004Addresses {
    // Ethereum Sepolia (lowercase — matches Address internal storage convention)
    public static final Address SEPOLIA_IDENTITY   = Address.from("0xf66e7cbdae1cb710fee7732e4e1f173624e137a7");
    public static final Address SEPOLIA_REPUTATION = Address.from("0x6e2a285294b5c74cb76d76ab77c1ef15c2a9e407");
    public static final Address SEPOLIA_VALIDATION = Address.from("0xc26171a3c4e1d958cea196a5e84b7418c58dca2c");

    // Ethereum Mainnet (to be added when verified from official deployment)
    // public static final Address MAINNET_IDENTITY = ...;

    private Erc8004Addresses() {}
}
```

#### EIP-712 Agent Wallet Signature (`sh.brane.core.crypto.erc8004`)

The Identity Registry's `setAgentWallet()` requires an EIP-712 signature proving wallet ownership.
This follows the same pattern as `Eip3009` in `sh.brane.core.crypto.eip3009`:

```java
// Package: sh.brane.core.crypto.erc8004
public final class Erc8004Wallet {

    // EIP-712 type for agent wallet binding
    public record AgentWalletBinding(BigInteger agentId, Address wallet, BigInteger deadline) {
        public static final TypeDefinition<AgentWalletBinding> DEFINITION =
            TypeDefinition.forRecord(
                AgentWalletBinding.class,
                "AgentWalletBinding",
                Map.of("AgentWalletBinding", List.of(
                    TypedDataField.of("agentId", "uint256"),
                    TypedDataField.of("wallet", "address"),
                    TypedDataField.of("deadline", "uint256")
                ))
            );
    }

    public static Signature signWalletBinding(
            AgentWalletBinding binding, Eip712Domain domain, Signer signer) {
        return TypedData.create(domain, AgentWalletBinding.DEFINITION, binding).sign(signer);
    }
}
```

### 2. Registry Clients (`brane-contract`)

#### Java Interfaces for Contract Binding

These interfaces are bound via `BraneContract.bind()` — matching the existing no-codegen pattern.

**Constraint:** `BraneContract.bind()` only allows `TransactionReceipt`, `void`, or `Void`
as return types for non-view (state-changing) functions. The Solidity `register()` returns
`uint256 agentId`, but since it's state-changing, the Java binding must return
`TransactionReceipt`. The `agentId` is extracted from the `Registered` event in the receipt.

**Constraint:** `BraneContract.bind()` does not support tuple/struct return types for view
functions. Methods like `getSummary()`, `readFeedback()`, and `getValidationStatus()` return
multi-value tuples. These cannot be bound via the proxy — they require raw `eth_call` +
manual `AbiDecoder` decoding. Only single-return-value view functions can use the proxy.

```java
// Internal interface — bound to the Identity Registry contract
// Only single-return view functions and write functions are proxy-bindable
interface IdentityRegistryContract {
    // Write functions → TransactionReceipt (agentId extracted from Registered event)
    TransactionReceipt register(String agentURI);
    TransactionReceipt setAgentURI(BigInteger agentId, String newURI);
    TransactionReceipt setMetadata(BigInteger agentId, String metadataKey, byte[] metadataValue);
    TransactionReceipt setAgentWallet(BigInteger agentId, Address newWallet, BigInteger deadline, byte[] signature);
    TransactionReceipt unsetAgentWallet(BigInteger agentId);

    // Single-return view functions → proxy-bindable
    byte[] getMetadata(BigInteger agentId, String metadataKey);
    Address getAgentWallet(BigInteger agentId);
}

// Internal interface — bound to the Reputation Registry contract
interface ReputationRegistryContract {
    // Single-return view functions → proxy-bindable
    Address getIdentityRegistry();

    // Write functions
    TransactionReceipt giveFeedback(BigInteger agentId, BigInteger value, BigInteger valueDecimals,
        String tag1, String tag2, String endpoint, String feedbackURI, byte[] feedbackHash);
    TransactionReceipt revokeFeedback(BigInteger agentId, BigInteger feedbackIndex);
    TransactionReceipt appendResponse(BigInteger agentId, Address clientAddress,
        BigInteger feedbackIndex, String responseURI, byte[] responseHash);

    // NOTE: getSummary(), readFeedback(), readAllFeedback() return tuples
    // and cannot be proxy-bound. Use raw eth_call + AbiDecoder instead.
}

// Internal interface — bound to the Validation Registry contract
interface ValidationRegistryContract {
    // Single-return view functions → proxy-bindable
    Address getIdentityRegistry();

    // Write functions
    TransactionReceipt validationRequest(Address validatorAddress, BigInteger agentId,
        String requestURI, byte[] requestHash);
    TransactionReceipt validationResponse(byte[] requestHash, BigInteger response,
        String responseURI, byte[] responseHash, String tag);

    // NOTE: getValidationStatus(), getSummary() return tuples
    // and cannot be proxy-bound. Use raw eth_call + AbiDecoder instead.
}
```

#### Tuple Return Decoding (Raw `eth_call`)

For view functions that return multiple values, `TrustlessAgents` bypasses the proxy
and uses raw `eth_call` + `AbiDecoder` directly:

```java
// Example: getSummary(uint256,address[],string,string) → (uint64, int128, uint8)
public FeedbackSummary getSummary(AgentId agentId, List<Address> clients, String tag1, String tag2) {
    HexData calldata = reputationAbi.encodeFunction("getSummary",
        agentId.value(), clients.toArray(Address[]::new), tag1, tag2);
    HexData result = client.call(CallRequest.builder()
        .to(reputationAddress)
        .data(calldata)
        .build());

    // Manual tuple decoding — 3 return values
    List<AbiType> decoded = AbiDecoder.decode(Hex.decode(result.value()),
        List.of(uint64Schema, int128Schema, uint8Schema));
    long count = ((UInt) decoded.get(0)).value().longValue();
    BigInteger summaryValue = ((Int) decoded.get(1)).value();
    int decimals = ((UInt) decoded.get(2)).value().intValue();
    return new FeedbackSummary(count, new FeedbackValue(summaryValue, decimals));
}
```

#### High-Level Client: `TrustlessAgents`

Wraps the three registries behind a single ergonomic API:

```java
public final class TrustlessAgents {

    // Factory — explicit addresses only (no chainId lookup until mainnet is verified)
    public static TrustlessAgents connect(Brane.Signer client,
        Address identity, Address reputation, Address validation);

    // Convenience for Sepolia testnet
    public static TrustlessAgents connectSepolia(Brane.Signer client);

    // Read-only variant (tuple reads via raw eth_call, no proxy needed for writes)
    public static TrustlessAgents.ReadOnly connectReadOnly(Brane client,
        Address identity, Address reputation, Address validation);

    // ─── Identity ──────────────────────────────────────────────
    // register() extracts agentId from the Registered event in the receipt
    public AgentId register(String agentURI);
    public AgentId register(String agentURI, List<MetadataEntry> metadata);
    public void setAgentURI(AgentId agentId, String newURI);
    public void setMetadata(AgentId agentId, String key, byte[] value);
    public byte[] getMetadata(AgentId agentId, String key);
    public void bindWallet(AgentId agentId, Address wallet, Signer walletSigner);
    public Address getAgentWallet(AgentId agentId);

    // ─── Reputation ───────────────────────────────────────────
    public void giveFeedback(AgentId agentId, FeedbackValue score,
        String tag1, String tag2);
    public void giveFeedback(AgentId agentId, FeedbackValue score,
        String tag1, String tag2, String endpoint,
        String feedbackURI, Hash feedbackHash);
    public void revokeFeedback(AgentId agentId, long feedbackIndex);
    public void appendResponse(AgentId agentId, Address client,
        long feedbackIndex, String responseURI, Hash responseHash);
    public FeedbackSummary getSummary(AgentId agentId);
    public FeedbackSummary getSummary(AgentId agentId,
        List<Address> clients, String tag1, String tag2);
    public List<FeedbackSubmitted> getAllFeedback(AgentId agentId);

    // ─── Validation ───────────────────────────────────────────
    public Hash requestValidation(Address validator, AgentId agentId,
        String requestURI, byte[] requestPayload);
    public void respondToValidation(Hash requestHash, int response,
        String responseURI, byte[] responsePayload, String tag);
    public ValidationStatus getValidationStatus(Hash requestHash);
    public ValidationSummary getValidationSummary(AgentId agentId);

    // ─── Events ───────────────────────────────────────────────
    public List<AgentRegistered> getRegistrations(long fromBlock, long toBlock);
    public List<FeedbackSubmitted> getFeedbackEvents(AgentId agentId,
        long fromBlock, long toBlock);
    public List<ValidationResponded> getValidationEvents(AgentId agentId,
        long fromBlock, long toBlock);
}
```

#### Summary Records

These are high-level domain types returned by `TrustlessAgents`, constructed from
raw tuple decoding — NOT decoded via `Abi.decodeEvents()`, so they can use wrapper types.

```java
public record FeedbackSummary(long count, FeedbackValue aggregateScore) {}

public record ValidationStatus(
    Address validator, AgentId agentId, int response,
    Hash responseHash, String tag, long lastUpdate) {}

public record ValidationSummary(long count, int averageResponse) {}
```

---

## Integration with Existing Brane Patterns

### Pattern 1: EIP-712 Typed Data (agent wallet binding)

Follows the `Eip3009` pattern exactly:

```
EIP-3009                           ERC-8004
─────────                          ─────────
TransferAuthorization (record)     AgentWalletBinding (record)
  └─ DEFINITION (TypeDefinition)     └─ DEFINITION (TypeDefinition)
Eip3009.sign(auth, domain, signer) Erc8004Wallet.signWalletBinding(binding, domain, signer)
Eip3009.usdcDomain(chainId, addr)  (domain built from registry address)
```

### Pattern 2: Contract Binding (no codegen)

Follows the existing `BraneContract.bind()` pattern. Write functions return
`TransactionReceipt`; return values are extracted from events in the receipt.

```java
// How it works internally
var identityAbi = Abi.fromJson(IDENTITY_REGISTRY_ABI);
var contract = BraneContract.bind(
    registryAddress, IDENTITY_REGISTRY_ABI, signerClient,
    IdentityRegistryContract.class);

// Write function returns TransactionReceipt — extract agentId from event
TransactionReceipt receipt = contract.register(agentURI);
List<AgentRegistered> events = identityAbi.decodeEvents("Registered", receipt.logs(), AgentRegistered.class);
AgentId id = events.getFirst().toAgentId();
```

### Pattern 3: Event Decoding

`LogFilter` is a record with factory methods (`byContract`, `byContracts`) — it does not
have a builder. For block-range queries, construct the record directly with `Optional` fields.

```java
// Decode on-chain events using existing ABI event decoding
Hash registeredTopic = Abi.eventTopic("Registered(uint256,string,address)");
LogFilter filter = new LogFilter(
    Optional.of(fromBlock),
    Optional.of(toBlock),
    Optional.of(List.of(identityRegistryAddress)),
    Optional.of(List.of(registeredTopic)));

List<LogEntry> logs = client.getLogs(filter);
List<AgentRegistered> events = abi.decodeEvents("Registered", logs, AgentRegistered.class);
```

### Pattern 4: Error Handling

No new exception subclass needed. ERC-8004 operations map to existing exceptions:

| Failure | Exception |
|---------|-----------|
| Contract revert (e.g., not agent owner) | `RevertException` |
| RPC communication failure | `RpcException` |
| ABI encoding/decoding issue | `AbiEncodingException` / `AbiDecodingException` |
| EIP-712 signature failure | `Eip712Exception` |

---

## Example Usage

### Register an Agent

```java
var agents = TrustlessAgents.connectSepolia(signerClient);

// Register with URI pointing to agent registration file
// Internally: sends tx, decodes Registered event from receipt, returns AgentId
AgentId myAgent = agents.register("https://myagent.example.com/.well-known/agent-registration.json");

// Set metadata
agents.setMetadata(myAgent, "version", "1.0".getBytes());

// Bind a payment wallet (EIP-712 signed)
agents.bindWallet(myAgent, paymentAddress, paymentWalletSigner);
```

### Give Feedback

```java
// Rate an agent's performance (87/100 on "quality")
agents.giveFeedback(
    agentId,
    FeedbackValue.of(87, 0),  // 87 with 0 decimals → BigInteger.valueOf(87)
    "quality", "api-call"
);

// Query reputation summary (uses raw eth_call + tuple decoding internally)
FeedbackSummary summary = agents.getSummary(agentId);
System.out.println("Score: " + summary.aggregateScore().toBigDecimal());
```

### Request Validation

```java
// Request a third-party to validate agent work
byte[] requestPayload = /* ... task description ... */;
Hash requestHash = agents.requestValidation(
    validatorAddress, myAgent,
    "ipfs://QmTaskDescription...", requestPayload);

// Validator responds (from validator's client)
agents.respondToValidation(requestHash, 95,
    "ipfs://QmValidationReport...", reportPayload, "accuracy");

// Check status
ValidationStatus status = agents.getValidationStatus(requestHash);
```

### Query Historical Events

```java
// Get all registrations in a block range
List<AgentRegistered> registrations = agents.getRegistrations(
    18_000_000L, 18_100_000L);

// Get feedback for a specific agent
List<FeedbackSubmitted> feedback = agents.getFeedbackEvents(
    agentId, 18_000_000L, 18_100_000L);
```

---

## Implementation Plan

### Phase 1: Core Types (`brane-core`)

1. Create `sh.brane.core.erc8004` package — domain types and event records
2. Create `sh.brane.core.crypto.erc8004` package — EIP-712 wallet binding (follows `eip3009` convention)
3. Add `AgentId`, `FeedbackValue` (BigInteger-based), `MetadataEntry` records
4. Add event records using raw ABI types: `AgentRegistered`, `FeedbackSubmitted`,
   `FeedbackRevoked`, `ValidationRequested`, `ValidationResponded`
5. Add `Erc8004Addresses` with known Sepolia deployments (lowercase)
6. Add `Erc8004Wallet` with EIP-712 wallet binding signature support
7. Unit tests for all types and EIP-712 signing

### Phase 2: Contract Bindings (`brane-contract`)

1. Add ABI JSON files for the three registries (from reference implementation)
2. Create proxy-bindable interfaces (write functions → `TransactionReceipt`,
   single-return view functions only)
3. Implement raw `eth_call` + `AbiDecoder` for tuple-returning view functions
   (`getSummary`, `readFeedback`, `getValidationStatus`, etc.)
4. Build `TrustlessAgents` client with `connect()` and `connectSepolia()` factories
5. Add `FeedbackSummary`, `ValidationStatus`, `ValidationSummary` records
6. Unit tests with mocked contract calls and mocked `eth_call` responses

### Phase 3: Integration Testing

1. Deploy reference contracts to local Anvil
2. End-to-end test: register → set metadata → bind wallet → give feedback → validate
3. Event querying tests across block ranges
4. Add to `brane-examples` with annotated examples

### Phase 4: Documentation

1. Javadoc on all public API
2. Add ERC-8004 section to `AGENTS.md`
3. Add examples to website docs

---

## Open Questions

1. **Mainnet addresses** — The ERC-8004 contracts are live on mainnet (Jan 2026) but verified
   addresses need to be confirmed from an official source before hardcoding. Until then, only
   `connectSepolia()` is provided; explicit addresses are required for other chains.

2. **Registration file parsing** — Should Brane include a JSON model for the agent registration
   file schema (`type`, `name`, `services[]`, `supportedTrust[]`, etc.)? This would add a
   Jackson dependency concern but enable programmatic agent discovery.

3. **WebSocket subscriptions** — Should `TrustlessAgents` expose a subscription API for real-time
   events (e.g., `onNewFeedback(AgentId, Consumer<FeedbackSubmitted>)`)? This would depend on
   `Brane.canSubscribe()` and the existing WebSocket infrastructure.

4. **Multi-chain agent identifiers** — ERC-8004 defines agent identifiers as
   `eip155:{chainId}:{registry}`. Should Brane model this as a dedicated `AgentIdentifier` type
   or keep it as a simple string?

---

## References

- [EIP-8004: Trustless Agents](https://eips.ethereum.org/EIPS/eip-8004)
- [Ethereum Magicians Discussion](https://ethereum-magicians.org/t/erc-8004-trustless-agents/25098)
- [Reference Implementation (ChaosChain)](https://github.com/ChaosChain/trustless-agents-erc-ri)
- [Awesome ERC-8004 Resources](https://github.com/sudeepb02/awesome-erc8004)
- [Composable Security Explainer](https://composable-security.com/blog/erc-8004-a-practical-explainer-for-trustless-agents/)
- [Mantle ERC-8004 Deployment](https://www.prnewswire.com/news-releases/mantle-unlocks-autonomous-economy-with-erc-8004-deployment-302688549.html)
